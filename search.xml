<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[main]]></title>
    <url>%2Fmain%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>娱乐</category>
      </categories>
      <tags>
        <tag>joy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[root-shadow]]></title>
    <url>%2Froot-shadow%2F</url>
    <content type="text"><![CDATA[如何查看控制台隐藏样式shadow-root1.打开视频打开一个视频链接，例如：http://m.v.baidu.com/watch/7870860677481105842.html?&amp;type=&amp;fr= 打开控制台，此时video样式显示如下： 2.设置点击右上角竖着的…，选择settings，如上图，显示如下图：找到Elements，勾选 show user agent shadow DOM，再回到控制台，就可以看到隐藏的样式了。如下图所示： [转自] 如何查看控制台隐藏样式shadow-root]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wechat-public]]></title>
    <url>%2Fwechat-public%2F</url>
    <content type="text"><![CDATA[如何判断用户是否已关注公众号一、微信公众平台配置1. 获取appid, appsecret，添加白名单登录微信公众平台，进入基本配置。开发中需要用到两个参数，appId和appSecret（appSecret只展示一次，需保存下来，否则需要重置获取）。获取access_token时需要添加IP白名单。点击查看点击修改 2. 添加网页授权进入公众号设置=》功能设置=》网页授权域名点击设置，input框中输入授权回调页的域名参考第1点（只能填写一个），下载第3点中的txt文档，上传至服务器的根目录。 二、php后端实现微信开放接口全局返回码说明参考：https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1433747234 1. 获取全局token此token有效期为2小时，可以暂存起来，过期后需要重新获取。PS： 项目中必须走同一个接口，否则容易互刷导致过期。123456789101112131415161718192021222324public static function getToken($appid, $appsecret)&#123; $url = 'https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid='.$appid.'&amp;secret='.$appsecret; return Curl::callWebServer($url);&#125;正确返回结果： &#123; "access_token": "ACCESS_TOKEN", "expires_in": 7200 &#125; 返回结果参数说明： 参数 说明 access_token 获取到的全局token expires_in 凭证有效时间，单位：秒 错误返回结果： &#123;"errcode": 40013, "errmsg": "invalid appid"&#125; 返回结果参数说明： 返回码 说明 -1 系统繁忙，此时请开发者稍候再试 0 请求成功 40001 AppSecret错误或者AppSecret不属于这个公众号，请开发者确认 AppSecret的正确性 40002 请确保grant_type字段值为client_credential 40164 调用接口的IP地址不在白名单中，请在接口IP白名单中进行设置。（小程序及小游戏调用不要求IP地址在白名单内。） 2. 获取用户关联公众号的openid分两步，先要获取到用户对公众号的授权码，然后拿这个码去获取临时access_token和openid。 获取用户授权码1234567891011121314151617181920212223public static function getCode($appId, $redirect_uri, $state=1, $scope='snsapi_base', $response_type='code')&#123; $url = 'https://open.weixin.qq.com/connect/oauth2/authorize?appid='.$appId.'&amp;redirect_uri='.$redirect_uri.'&amp;response_type='.$response_type.'&amp;scope='.$scope.'&amp;state='.$state.'#wechat_redirect'; header('Location: '.$url, true, 301);&#125;正确返回结果： 返回code码，并且跳转回调页面$redirect_uri 错误返回结果： &#123;"errcode": 10003, "errmsg": "redirect_uri域名与后台配置不一致"&#125; 返回结果参数说明： 返回码 说明 10003 redirect_uri域名与后台配置不一致 10004 此公众号被封禁 10005 此公众号并没有这些scope的权限 10006 必须关注此测试号 10009 操作太频繁了，请稍后重试 10010 scope不能为空 10011 redirect_uri不能为空 10012 appid不能为空 10013 state不能为空 10015 公众号未授权第三方平台，请检查授权状态 10016 不支持微信开放平台的Appid，请使用公众号Appid 通过getCode获取到的code换取网页授权的access_token和openid1234567891011121314151617181920212223public static function getAccessToken($code, $appid, $appsecret, $grant_type='authorization_code')&#123; $url = 'https://api.weixin.qq.com/sns/oauth2/access_token?appid='.$appid.'&amp;secret='.$appsecret.'&amp;code='.$code.'&amp;grant_type='.$grant_type.''; return Curl::callWebServer($url);&#125; 正确返回结果： &#123; "access_token": "ACCESS_TOKEN", "expires_in": 7200, "refresh_token": "REFRESH_TOKEN", "openid": "OPENID", "scope": "SCOPE" &#125; 返回参数说明 参数 描述 access_token 网页授权接口调用凭证,注意：此access_token与基础支持的access_token不同 expires_in access_token接口调用凭证超时时间，单位（秒） refresh_token 用户刷新access_token openid 用户唯一标识，请注意，在未关注公众号时，用户访问公众号的网页，也会产生一个用户和公众号唯一的OpenID scope 用户授权的作用域，使用逗号（,）分隔 错误返回结果： &#123;"errcode":40029, "errmsg":"invalid code"&#125; 3. 获取用户信息使用第2步中获取的openId和第1步中获取的token去获取用户信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static function getUserInfo($openId, $token)&#123; $url = 'https://api.weixin.qq.com/cgi-bin/user/info?access_token='.$token.'&amp;openid='.$openId.'&amp;lang=zh_CN'; return Curl::callWebServer($queryUrl, '', 'GET');&#125;正确返回结果： &#123; "subscribe": 1, "openid": "o6_bmjrPTlm6_2sgVt7hMZOPfL2M", "nickname": "Band", "sex": 1, "language": "zh_CN", "city": "广州", "province": "广东", "country": "中国", "headimgurl":"http://thirdwx.qlogo.cn/mmopen/g3MonUZtNHkdmzicIlibx6iaFqAc56vxLSUfpb6n5WKSYVY0ChQKkiaJSgQ1dZuTOgvLLrhJbERQQ4eMsv84eavHiaiceqxibJxCfHe/0", "subscribe_time": 1382694957, "unionid": " o6_bmasdasdsad6_2sgVt7hMZOPfL" "remark": "", "groupid": 0, "tagid_list":[128,2], "subscribe_scene": "ADD_SCENE_QR_CODE", "qr_scene": 98765, "qr_scene_str": "" &#125; 返回参数说明： 参数 说明 subscribe 用户是否订阅该公众号标识，值为0时，代表此用户没有关注该公众号，拉取不到其余信息。 openid 用户的标识，对当前公众号唯一 nickname 用户的昵称 sex 用户的性别，值为1时是男性，值为2时是女性，值为0时是未知 city 用户所在城市 country 用户所在国家 province 用户所在省份 language 用户的语言，简体中文为zh_CN headimgurl 用户头像，最后一个数值代表正方形头像大小（有0、46、64、96、132数值可选，0代表640*640正方形头像），用户没有头像时该项为空。若用户更换头像，原有头像URL将失效。 subscribe_time 用户关注时间，为时间戳。如果用户曾多次关注，则取最后关注时间 unionid 只有在用户将公众号绑定到微信开放平台帐号后，才会出现该字段。 remark 公众号运营者对粉丝的备注，公众号运营者可在微信公众平台用户管理界面对粉丝添加备注 groupid 用户所在的分组ID（兼容旧的用户分组接口） tagid_list 用户被打上的标签ID列表 subscribe_scene 返回用户关注的渠道来源，ADD_SCENE_SEARCH 公众号搜索，ADD_SCENE_ACCOUNT_MIGRATION 公众号迁移，ADD_SCENE_PROFILE_CARD 名片分享，ADD_SCENE_QR_CODE 扫描二维码，ADD_SCENEPROFILE LINK 图文页内名称点击，ADD_SCENE_PROFILE_ITEM 图文页右上角菜单，ADD_SCENE_PAID 支付后关注，ADD_SCENE_OTHERS 其他 qr_scene 二维码扫码场景（开发者自定义） qr_scene_str 二维码扫码场景描述（开发者自定义）错误结果： &#123;"errcode":40013,"errmsg":"invalid appid"&#125; 三、使用判断是否关注过，此处为入口：1234public function isConcern($appId, $appSecret) &#123; $param = ''; // 如果有参数 $this-&gt;getCode($appId, U('callback', 'param='.$param), 1 ,'snsapi_base');&#125; 授权后回调1234567891011121314151617181920public function callback()&#123; $isconcern = 0; $code = $this-&gt;_get('code'); $param = $this-&gt;_get('param'); $appId = C('appId'); // config中配置 $appSecret = C('appSecret'); $accessTokenInfo = $this-&gt;getAccessToken($code, $appId, $appSecret); $openId = $accessTokenInfo['openid']; $accessToken = $accessTokenInfo['access_token']; $token = $this-&gt;getToken($appId, $appSecret); $userInfo = $this-&gt;getUserInfo($openId, $token['access_token']); if($userInfo['subscribe'] == 1)&#123; $this-&gt;assign('userInfo', $userInfo); $isconcern = 1; // 已关注 &#125; else &#123; $isconcern = 0; // 未关注 &#125; $this-&gt;assign('openid', $openId); $this-&gt;display('page');&#125; 此时页面上可以获取到userInfo和isconcern，isconcern为1时表示已关注公众号，否则未关注。 [转自] 如何判断用户是否已关注公众号]]></content>
      <categories>
        <category>问题总结</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[atom]]></title>
    <url>%2Fatom%2F</url>
    <content type="text"><![CDATA[Atom一个跨平台文本编辑器Atom 是github专门为程序员推出的一个跨平台文本编辑器。文件太大时容易卡死，但是目前对于我们前端开发的项目还是完全可以支撑的，打开项目快的简直要飞起来（相比之前使用webstorm而言，个人不太喜欢sublime。）。安装以下一些插件后，使用起来非常酷炫。 cd ~/.atom/packagesapm install atom-beautify 代码格式一键美化apm install language-vuejs 安装vueapm install minimap 代码小地图apm install tree-view-git-status 代码Git状态图标apm install script 运行多种开发语言脚本apm install Emmet 使用缩写语法快速编写 HTML、CSS 以及实现其他的功能apm install color-picker 颜色选择器apm install file-type-icons 更改左侧分级视图的文件图标和颜色apm install linter-csslint css样式检测apm install autocomplete-paths 自动提示文件路径apm install autocomplete-paths 路径补全apm install autoclose-html html 自动补全关闭标签apm install activate-power-mode 这个很酷炫的，你可以试试apm install language-wepy 支持wepy （微信小程序）apm install sync-settings 配置你个人的 Github access token。然后在 Atom Command Palette 中输入 sync-settings:backup，会自动将 Atom 的配置备份在 gist 中 [转自] Atom一个跨平台文本编辑器]]></content>
      <categories>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-css-weex-document]]></title>
    <url>%2Fhexo-css-weex-document%2F</url>
    <content type="text"><![CDATA[hexo+css项目部署到github仿写weex使用手册一、概述前面讲了如何使用hexo+css搭建自己的博客，今天主要是总结下如何把本地能访问的静态的博客部署到github上。以重写weex使用手册为例（不要问我为什么这么无聊，等你怀孕了就知道了）。 博客地址：https://stardew516.github.io/（迁移：https://stardew.github.io/）博客部署地址：https://github.com/stardew516/stardew516.github.io（https://github.com/stardew/stardew.github.io） 博客源码地址：https://github.com/stardew516/document 分支master: 原本打算用来部署，后面发现不可用，弃 分支development：基础代码存放，实现本地博客 分支deploy：修改一些信息，部署到github上所用 二、实现1. 使用hexo+css写好一套能在本地跑通的静态博客 可参照 hexo+css创建自己的blog（搭建） 2. 安装 hexo-deployer-git: npm install hexo-deployer-git --save3. 在github上新建一个仓库，注意命名格式如下图，用户名.github.io 4. _config.yml 中配置 123456# 部署部分的设置deploy: type: git repo: https://github.com/stardew516/stardew516.github.io.git branch: master message: hexo + css 5. 生成文件: hexo generate6. 部署: hexo deploy7. 访问: https://stardew516.github.io/[转自] hexo+css项目部署到github（仿写weex使用手册）]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[excel-download]]></title>
    <url>%2Fexcel-download%2F</url>
    <content type="text"><![CDATA[纯前端实现excel表格导入导出前言github: https://github.com/stardew516/xlsxDwonload 以往做excel表格下载功能的时候，都是后端生成好表格后，存储在某个地方，然后给前端一个链接，前端使用a标签加download下载，或者使用node。其实纯前端也是可以做表格下载的，有一个很好用的javascript插件叫js-xlsx。 js-xlsxgithub：https://github.com/tealeg/xlsx使用js-xlsx时，前端可以将后端返回的json数据拼接成自己需要导出的格式，下载到电脑中，完全不依赖后端。导入只需像平时一样选择文件，然后解析excel表格数据，转换成json格式。 目前js-xlsx对各浏览器的支持情况如下图所示： 用法以vue使用为例 vue-cli脚手架搭好框架 安装包xlsxnpm install xlsx --save 代码实现（全） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227&lt;template&gt; &lt;div class="index" v-loading.fullscreen.lock="fullscreenLoading" element-loading-text="拼命加载中..."&gt; &lt;input type="file" @change="importFile(this)" id="imFile" style="display: none" accept="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel"/&gt; &lt;a id="downlink"&gt;&lt;/a&gt; &lt;el-button class="button" @click="uploadFile()"&gt;导入&lt;/el-button&gt; &lt;el-button class="button" @click="downloadFile(excelData)"&gt;导出&lt;/el-button&gt; &lt;!--错误信息提示--&gt; &lt;el-dialog title="提示" v-model="errorDialog" size="tiny"&gt; &lt;span&gt;&#123;&#123;errorMsg&#125;&#125;&lt;/span&gt; &lt;span slot="footer" class="dialog-footer"&gt; &lt;el-button type="primary" @click="errorDialog=false"&gt;确认&lt;/el-button&gt; &lt;/span&gt; &lt;/el-dialog&gt; &lt;!--展示导入信息--&gt; &lt;el-table :data="excelData" tooltip-effect="dark"&gt; &lt;el-table-column label="名称" prop="name" show-overflow-tooltip&gt;&lt;/el-table-column&gt; &lt;el-table-column label="分量" prop="size" show-overflow-tooltip&gt;&lt;/el-table-column&gt; &lt;el-table-column label="口味" prop="taste" show-overflow-tooltip&gt;&lt;/el-table-column&gt; &lt;el-table-column label="单价(元)" prop="price" show-overflow-tooltip&gt;&lt;/el-table-column&gt; &lt;el-table-column label="剩余(份)" prop="remain" show-overflow-tooltip&gt;&lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // 引入xlsx var XLSX = require('xlsx') export default &#123; name: 'Index', data () &#123; return &#123; fullscreenLoading: false, // 加载中 imFile: '', // 导入文件el outFile: '', // 导出文件el errorDialog: false, // 错误信息弹窗 errorMsg: '', // 错误信息内容 excelData: [ // 测试数据 &#123; name: '红烧鱼', size: '大', taste: '微辣', price: '40', remain: '100' &#125;, &#123; name: '麻辣小龙虾', size: '大', taste: '麻辣', price: '138', remain: '200' &#125;, &#123; name: '清蒸小龙虾', size: '大', taste: '清淡', price: '138', remain: '200' &#125;, &#123; name: '香辣小龙虾', size: '大', taste: '特辣', price: '138', remain: '200' &#125;, &#123; name: '十三香小龙虾', size: '大', taste: '中辣', price: '138', remain: '108' &#125;, &#123; name: '蒜蓉小龙虾', size: '大', taste: '中辣', price: '138', remain: '100' &#125;, &#123; name: '凉拌牛肉', size: '中', taste: '中辣', price: '48', remain: '60' &#125;, &#123; name: '虾仁寿司', size: '大', taste: '清淡', price: '29', remain: '无限' &#125;, &#123; name: '海苔寿司', size: '大', taste: '微辣', price: '26', remain: '无限' &#125;, &#123; name: '金针菇寿司', size: '大', taste: '清淡', price: '23', remain: '无限' &#125;, &#123; name: '泡菜寿司', size: '大', taste: '微辣', price: '24', remain: '无限' &#125;, &#123; name: '鳗鱼寿司', size: '大', taste: '清淡', price: '28', remain: '无限' &#125;, &#123; name: '肉松寿司', size: '大', taste: '清淡', price: '22', remain: '无限' &#125;, &#123; name: '三文鱼寿司', size: '大', taste: '清淡', price: '30', remain: '无限' &#125;, &#123; name: '蛋黄寿司', size: '大', taste: '清淡', price: '20', remain: '无限' &#125; ] &#125; &#125;, mounted () &#123; this.imFile = document.getElementById('imFile') this.outFile = document.getElementById('downlink') &#125;, methods: &#123; uploadFile: function () &#123; // 点击导入按钮 this.imFile.click() &#125;, downloadFile: function (rs) &#123; // 点击导出按钮 let data = [&#123;&#125;] for (let k in rs[0]) &#123; data[0][k] = k &#125; data = data.concat(rs) this.downloadExl(data, '菜单') &#125;, importFile: function () &#123; // 导入excel this.fullscreenLoading = true let obj = this.imFile if (!obj.files) &#123; this.fullscreenLoading = false return &#125; var f = obj.files[0] var reader = new FileReader() let $t = this reader.onload = function (e) &#123; var data = e.target.result if ($t.rABS) &#123; $t.wb = XLSX.read(btoa(this.fixdata(data)), &#123; // 手动转化 type: 'base64' &#125;) &#125; else &#123; $t.wb = XLSX.read(data, &#123; type: 'binary' &#125;) &#125; let json = XLSX.utils.sheet_to_json($t.wb.Sheets[$t.wb.SheetNames[0]]) console.log(typeof json) $t.dealFile($t.analyzeData(json)) // analyzeData: 解析导入数据 &#125; if (this.rABS) &#123; reader.readAsArrayBuffer(f) &#125; else &#123; reader.readAsBinaryString(f) &#125; &#125;, downloadExl: function (json, downName, type) &#123; // 导出到excel let keyMap = [] // 获取键 for (let k in json[0]) &#123; keyMap.push(k) &#125; console.info('keyMap', keyMap, json) let tmpdata = [] // 用来保存转换好的json json.map((v, i) =&gt; keyMap.map((k, j) =&gt; Object.assign(&#123;&#125;, &#123; v: v[k], position: (j &gt; 25 ? this.getCharCol(j) : String.fromCharCode(65 + j)) + (i + 1) &#125;))).reduce((prev, next) =&gt; prev.concat(next)).forEach(function (v) &#123; tmpdata[v.position] = &#123; v: v.v &#125; &#125;) let outputPos = Object.keys(tmpdata) // 设置区域,比如表格从A1到D10 let tmpWB = &#123; SheetNames: ['mySheet'], // 保存的表标题 Sheets: &#123; 'mySheet': Object.assign(&#123;&#125;, tmpdata, // 内容 &#123; '!ref': outputPos[0] + ':' + outputPos[outputPos.length - 1] // 设置填充区域 &#125;) &#125; &#125; let tmpDown = new Blob([this.s2ab(XLSX.write(tmpWB, &#123;bookType: (type === undefined ? 'xlsx' : type), bookSST: false, type: 'binary'&#125; // 这里的数据是用来定义导出的格式类型 ))], &#123; type: '' &#125;) // 创建二进制对象写入转换好的字节流 var href = URL.createObjectURL(tmpDown) // 创建对象超链接 this.outFile.download = downName + '.xlsx' // 下载名称 this.outFile.href = href // 绑定a标签 this.outFile.click() // 模拟点击实现下载 setTimeout(function () &#123; // 延时释放 URL.revokeObjectURL(tmpDown) // 用URL.revokeObjectURL()来释放这个object URL &#125;, 100) &#125;, analyzeData: function (data) &#123; // 此处可以解析导入数据 return data &#125;, dealFile: function (data) &#123; // 处理导入的数据 console.log(data) this.imFile.value = '' this.fullscreenLoading = false if (data.length &lt;= 0) &#123; this.errorDialog = true this.errorMsg = '请导入正确信息' &#125; else &#123; this.excelData = data &#125; &#125;, s2ab: function (s) &#123; // 字符串转字符流 var buf = new ArrayBuffer(s.length) var view = new Uint8Array(buf) for (var i = 0; i !== s.length; ++i) &#123; view[i] = s.charCodeAt(i) &amp; 0xFF &#125; return buf &#125;, getCharCol: function (n) &#123; // 将指定的自然数转换为26进制表示。映射关系：[0-25] -&gt; [A-Z]。 let s = '' let m = 0 while (n &gt; 0) &#123; m = n % 26 + 1 s = String.fromCharCode(m + 64) + s n = (n - m) / 26 &#125; return s &#125;, fixdata: function (data) &#123; // 文件流转BinaryString var o = '' var l = 0 var w = 10240 for (; l &lt; data.byteLength / w; ++l) &#123; o += String.fromCharCode.apply(null, new Uint8Array(data.slice(l * w, l * w + w))) &#125; o += String.fromCharCode.apply(null, new Uint8Array(data.slice(l * w))) return o &#125; &#125; &#125;&lt;/script&gt;&lt;!-- Add "scoped" attribute to limit CSS to this component only --&gt;&lt;style&gt; .el-table th&gt;.cell &#123; text-align: center; &#125; .button &#123; margin-bottom: 20px; &#125;&lt;/style&gt; 启动项目npm run dev 效果图 [转自] 纯前端实现excel表格导入导出]]></content>
      <categories>
        <category>小例子</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-css-issue]]></title>
    <url>%2Fhexo-css-issue%2F</url>
    <content type="text"><![CDATA[hexo+css遇到的unexpected token问题问题背景使用hexo+css模拟实现weex文档，页面Weex 和 Vue 2.x 的语法差异遇到问题。 问题描述新建页面，copy进去内容，hexo server运行，控制台报错：123456789101112131415161718192021222324FATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlTemplate render error: (unknown path) [Line 17, Column 9] unexpected token: ! at Object.exports.prettifyError (/Users/weilu/Desktop/weilu/code/document/folder/node_modules/nunjucks/src/lib.js:34:15) at Obj.extend.render (/Users/weilu/Desktop/weilu/code/document/folder/node_modules/nunjucks/src/environment.js:469:27) at Obj.extend.renderString (/Users/weilu/Desktop/weilu/code/document/folder/node_modules/nunjucks/src/environment.js:327:21) at /Users/weilu/Desktop/weilu/code/document/folder/node_modules/hexo/lib/extend/tag.js:66:9 at Promise._execute (/Users/weilu/Desktop/weilu/code/document/folder/node_modules/bluebird/js/release/debuggability.js:300:9) at Promise._resolveFromExecutor (/Users/weilu/Desktop/weilu/code/document/folder/node_modules/bluebird/js/release/promise.js:483:18) at new Promise (/Users/weilu/Desktop/weilu/code/document/folder/node_modules/bluebird/js/release/promise.js:79:10) at Tag.render (/Users/weilu/Desktop/weilu/code/document/folder/node_modules/hexo/lib/extend/tag.js:64:10) at Object.tagFilter [as onRenderEnd] (/Users/weilu/Desktop/weilu/code/document/folder/node_modules/hexo/lib/hexo/post.js:266:16) at /Users/weilu/Desktop/weilu/code/document/folder/node_modules/hexo/lib/hexo/render.js:65:19 at tryCatcher (/Users/weilu/Desktop/weilu/code/document/folder/node_modules/bluebird/js/release/util.js:16:23) at Promise._settlePromiseFromHandler (/Users/weilu/Desktop/weilu/code/document/folder/node_modules/bluebird/js/release/promise.js:512:31) at Promise._settlePromise (/Users/weilu/Desktop/weilu/code/document/folder/node_modules/bluebird/js/release/promise.js:569:18) at Promise._settlePromise0 (/Users/weilu/Desktop/weilu/code/document/folder/node_modules/bluebird/js/release/promise.js:614:10) at Promise._settlePromises (/Users/weilu/Desktop/weilu/code/document/folder/node_modules/bluebird/js/release/promise.js:693:18) at Async._drainQueue (/Users/weilu/Desktop/weilu/code/document/folder/node_modules/bluebird/js/release/async.js:133:16) at Async._drainQueues (/Users/weilu/Desktop/weilu/code/document/folder/node_modules/bluebird/js/release/async.js:143:10) at Immediate.Async.drainQueues (/Users/weilu/Desktop/weilu/code/document/folder/node_modules/bluebird/js/release/async.js:17:14) at runCallback (timers.js:574:20) at tryOnImmediate (timers.js:554:5) at processImmediate [as _immediateCallback] (timers.js:533:5) 定位问题问题定位到if=&quot;&amp;#123;&amp;#123;!foo&amp;#125;&amp;#125;&quot;这句文案。文档中的效果如下： 分析问题：报错信息写的很明确，unexpected token: !，!是不被期望的。其实这是因为使用了&amp;#123;&amp;#123;...&amp;#125;&amp;#125;导致的，在hexo中双括号会被解析，双括号里的内容会被当做变量解析。 解决问题以下是几种可能的解决方案 网上找到方法说使用&#39;可以不解析&#123;&#123;，其实不然，使用&#39;后会不解析转义后的特俗字符，例如改为 12`if="&amp;#125;&amp;#125;!foo&amp;#125;&amp;#125;"`还是会解析，会报同样的错误，所以`包裹是不能解决问题的。 还有的是说使用&#39;&#39;&#39;三个反引号，三个&#39;&#39;&#39;确实可以解决解析方面的问题，但是不能解决我们这里的问题，我们看文档可以知道，这句if=&quot;&amp;#123;&amp;#123;!foo&amp;#125;&amp;#125;&quot;是在表格中的，而&#39;&#39;&#39;生成的是代码块，所以三个反引号是不能最终解决问题的。 转义。一般很多类似unexpected token: ***的问题，都可以使用转义的方法解决，关于转义字符，可以看我上一篇文章hexo+css创建自己的blog（语法手册），里面最底下有各种特殊字符对应的转义码。以下是我解决问题的三个过程： 12345678`if="&amp;#123;&amp;#123;!foo&amp;#125;&amp;#125;"`这种方式时，`根本不会把转义过后的内容反转义回去，效果图如下图1。图1的效果并不是我们期望的，只是我们知道`最终在页面展示的效果是包裹在code中的，所以我们可以用如下方式，效果如下图2。&lt;code&gt;if="&amp;#123;&amp;#123;!foo&amp;#125;&amp;#125;"&lt;/code&gt;图2中可以看出，双引号变成了中文的，这也不是我们期望的，需要转义一下，改为如下方式，完美解决问题，结果如图3。&lt;code&gt;if=&amp;quot;&amp;#123;&amp;#123;!foo&amp;#125;&amp;#125;&amp;quot;&lt;/code&gt; 图1： 图2： 图3： 总结使用hexo创建博客写文章的时候，遇到的问题几乎都是特殊字符解析方面的问题，所以应该尽可能少写一些特殊字符，如果实在需要，可以使用转义码。遇到问题时，解决思路可以考虑下转义码+html标签。 [转自] hexo+css遇到的unexpected token问题]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-css-build]]></title>
    <url>%2Fhexo-css-build%2F</url>
    <content type="text"><![CDATA[hexo+css创建自己的blog（搭建）一、什么是hexoHexo是一个快速、简洁且高效的博客框架，使用Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。目前比较火的vue和weex的文档都是使用hexo框架实现的。 二、hexo的安装安装hexo前，确保电脑中已经安装了node和git。 node安装12345方法一、 直接安装node：ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"方法二、 先安装homebrew： /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 后安装node：brew install node git安装12先安装homebrew： /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"后安装git：brew install git hexo安装1npm install -g hexo-cli 三、创建项目 新建项目: hexo init folder 进入: cd folder&gt; 安装依赖包: npm install 新建一篇文章: hexo new iOS-APIs (文件会在/source/_posts下) 启动: hexo server 浏览器打开: http://localhost:4000/document/ 四、hexo配置配置文件为_config.yml参考: https://hexo.io/docs/configuration.htmlgithub: https://github.com/hexojs/hexo/ Site （网站） 网站标题title: weex使用手册 网站副标题subtitle: weex中文手册 网站描述description: 整理weex手册, 包括通用特性, 内建组件, 内建模块, CSS 单位, 通用事件, Native DOM APIs, Weex 实例变量, Web 标准, JS Service, Vue, 高阶知识, 迁移 作者名字author: stardew 网站使用的语言language: 简体中文 网站时区Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。timezone: UTC URL （网址）如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。 网址url: https://github.com/stardew516/document 网站根目录root: /document/ 文章的 永久链接 格式permalink: :year/:month/:day/:title/ 永久链接中各部分的默认值permalink_defaults: Directory （目录） 资源文件夹，这个文件夹用来存放内容。source_dir: source 公共文件夹，这个文件夹用于存放生成的站点文件。public_dir: public 标签文件夹tag_dir: tags 归档文件夹archive_dir: archives 分类文件夹category_dir: categories Include code 文件夹code_dir: downloads/code 国际化（i18n）文件夹i18n_dir: :lang 跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。skip_render: Writing （文章） 新建文章的文件名称new_post_name: :title.md 预设布局default_layout: post 在中文和英文之间加入空格auto_spacing: false 把标题转换为 title casetitlecase: false 在新标签中打开链接external_link: true 把文件名称转换为 (1) 小写或 (2) 大写filename_case: 0 显示草稿render_drafts: false 启动 Asset 文件夹post_asset_folder: true 把链接改为与根目录的相对位址relative_link: false 显示未来的文章future: true 代码块的设置highlight: enable: true line_number: true auto_detect: true tab_replace: Home page setting （主页设置）1. path: 博客索引页的跟路径,默认为空 2. per_page: 每页展示的文章量, 为0时表示不分页 3. order_by: 排序, 默认日期降序 index_generator: path: &apos;&apos; per_page: 10 order_by: -date Category &amp; Tag （分类 &amp; 标签） 默认分类default_category: uncategorized 分类别名category_map: 标签别名tag_map: Date / Time format （日期 / 时间格式）hexo使用Moment.js来解析和显示时间。可以参照http://momentjs.com/docs/#/displaying/format/来自定义日期格式。 日期格式date_format: YYYY-MM-DD 时间格式time_format: HH:mm:ss Pagination （分页） 每页显示的文章量 (0 = 关闭分页功能)per_page: 10 分页目录pagination_dir: page Extensions （扩展）插件: https://hexo.io/plugins/主题: https://hexo.io/themes/ 当前主题名称。值为false时禁用主题theme: landscape Deployment （部署）参考: https://hexo.io/docs/deployment.html 部署部分的配置 deploy: type: git repo: https://github.com/stardew516/document branch: master message: hexo + css 五、部署github上部署: 安装hexo-deployer-git: npm install hexo-deployer-git --save _config.yml 中配置 123456# 部署部分的设置deploy: type: git repo: https://github.com/stardew516/document branch: master message: hexo + css 终端进入目录,运行: hexo deploy [转自] hexo+css创建自己的blog（搭建）]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-css-document]]></title>
    <url>%2Fhexo-css-document%2F</url>
    <content type="text"><![CDATA[hexo语法使用手册注意：因语法问题，有些hexo的效果在segmentfault中无法正常显示。 1. 列表123456789有序号:1. 第一点2. 第二点3. 第三点无序号:* 星号列表+ 加号列表- 减号列表 效果: 第一点 第二点 第三点 星号列表 加号列表 减号列表 2. 块注释12345678910&gt; 区块引用或者:&#123;% blockquote %&#125;普通的引用&#123;% endblockquote %&#125;嵌套引用&gt; 一层引用&gt;&gt; 两层引用 效果: 区块引用 注：blockquote效果不显示普通的引用下一行 一层引用 两层引用 3. 分割线12***--- 效果: *4. 链接1234[这是一个绝对路径的链接](https://hexo.io/zh-cn/docs/writing.html)[这是一个相对路径的链接](/document/2017/08/07/hello-world/)&#123;% link text url [external] [title] %&#125;你好,我是&#123;% link 百度 https://www.baidu.com/ 搜索 度娘 %&#125;. 效果：这是一个绝对路径的链接这是一个相对路径的链接 注：效果不显示你好,我是百度. 5. 加粗12**双星加粗**__双下划线加粗__ 效果：双星加粗双下划线加粗 6. 斜体12*星号斜体*_下划线斜体_ 效果：星号斜体下划线斜体 7. 图片1234567![图1. 我最爱的炮兵](/document/assert/img.jpg "Title")![图2. 我的头像](https://sfault-avatar.b0.upaiyun.com/267/966/2679662993-581186b9d2f8a_big64 "Title")&#123;% img [class names] /path/to/image [width] [height] [title text [alt text]] %&#125;&#123;% img [box-model] http://weex.apache.org/cn/references/images/css-boxmodel.png 377 340 weex 盒模型 %&#125; 效果： 注：效果不显示 8. 代码123多行代码块使用三个`单行代码使用一个`console.log('hello world!') 9. 标题12345678910111213方法1: - 和 = (任何数量等效)一级标题===二级标题---方法2: ## 一级 H1## 二级 H2### 三级 H3#### 四级 H4##### 五级 H5###### 六级 H6 效果：方法1: - 和 = 一级标题二级标题方法2: # 一级二级三级四级五级六级10. jsfiddle123&#123;% jsfiddle shorttag [tabs] [skin] [width] [height] %&#125;&#123;% jsfiddle stardew/ffnm6Lsd/1/ %&#125; 点击左上角fiddles 注：效果不显示 11. iframe123&#123;% iframe url [width] [height] %&#125;&#123;% iframe https://www.baidu.com/ 500 300 %&#125; 注：效果不显示 12. 表格1234567891011121314151617181920212223242526左左中右对齐dog | bird | cat--- | ---- | ---foo | foo | foobar | bar | barbaz | baz | bazdog | bird | cat:---- | :---- | :----foo | foo | foobar | bar | barbaz | baz | bazdog | bird | cat:----: | :----: | :----:foo | foo | foobar | bar | barbaz | baz | bazdog | bird | cat----: | ----: | ----:foo | foo | foobar | bar | barbaz | baz | baz dog bird cat foo foo foo bar bar bar baz baz baz dog bird cat foo foo foo bar bar bar baz baz baz dog bird cat foo foo foo bar bar bar baz baz baz dog bird cat foo foo foo bar bar bar baz baz baz 13. 原生代码12345678&#123;% raw %&#125;content&#123;% endraw %&#125;或者直接content&lt;span class="color-box" style="background:#FF00FF;color:#FF00FF"&gt; yy &lt;/span&gt; #FF00FF 注：效果不显示 yy #FF00FF 14. 转义 符号 转义 &#33; &amp;#33; &#34; &amp;#34; 或 &amp;quot; &#35; &amp;#35; &#36; &amp;#36; &#37; &amp;#37; &#38; &amp;#38; 或 &amp;amp; &#39; &amp;#39; &#40; &amp;#40; &#41; &amp;#41; &#42; &amp;#42; &#43; &amp;#43; &#60; &amp;#60; 或 &amp;lt; &#61; &amp;#61; &#62; &amp;#62; 或 &amp;gt; &#63; &amp;#63; &#64; &amp;#64; &#91; &amp;#91; &#92; &amp;#92; &#93; &amp;#93; &#123; &amp;#123; &#124; &amp;#124; &#125; &amp;#125; [转自] hexo+css创建自己的blog（语法手册）]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vueresource-405]]></title>
    <url>%2Fvueresource-405%2F</url>
    <content type="text"><![CDATA[vue-resource报错450的解决方案vue-resource(github)地址：https://github.com/pagekit/vue-resource 一、基本使用1.页面引入12import vueResource from 'vue-resource'Vue.use(vueResource) 2. 调取接口12345678Vue.http.post(url, &#123; 'data1': data1, 'data2': 'data2'&#125;).then(response =&gt; &#123; console.log('success', response)&#125;, response =&gt; &#123; console.log('error', response)&#125;) 二、报错450定位错误信息：请求header没有完全一一对应。Content-Type: application/x-www-form-urlencoded; charset=UTF-8应为Content-Type: application/json; charset=UTF-8，检查页面代码，发现已经设置了12345Vue.http.interceptors.push(function (request, next) &#123; request.headers.set('Content-Type', 'application/json; charset=UTF-8') request.headers.set('Content-Type', 'application/json') next()&#125;) 只是页面没有起作用而已，那究竟是什么原因导致页面设置的Content-Type失效了呢？继续追溯，发现跟这行代码有关123// Vue.http.options.crossOrigin = true // Vue.http.options.emulateHTTP = trueVue.http.options.emulateJSON = true //（跟这行代码有关） 三、分析下面分别来讲一下这几行代码的用处，以及emulateJSON是怎么影响到Content-Type设置的。 1. Vue.http.options.crossOrigin这个很明显是设置跨域的，此处不多讲。 2. Vue.http.options.emulateHTTP参考地址：https://github.com/pagekit/vue-resource/blob/develop/src/http/interceptor/method.js摘出源码12345678910111213/** * HTTP method override Interceptor. */export default function (request, next) &#123; if (request.emulateHTTP &amp;&amp; /^(PUT|PATCH|DELETE)$/i.test(request.method)) &#123; request.headers.set('X-HTTP-Method-Override', request.method); request.method = 'POST'; &#125; next();&#125; 大概的意思就是如果请求方式为PUT|PATCH|DELETE，服务器又没法处理这几类请求的时候，设置Vue.http.options.emulateHTTP = true的话可以将X-HTTP-Method-Override设置为PUT|PATCH|DELETE，然后使用普通的post进行请求。关于X-HTTP-Method-Override讲一下，它的使用场景是：在某些HTTP代理不支持类似PUT|PATCH|DELETE这些类型HTTP请求的情况下，可以通过另一种完全违背协议的HTTP方法来”代理”。这种协议就是，使客户端发出HTTP POST请求并设置header里X-HTTP-Method-Override值为PUT|PATCH|DELETE。 3. Vue.http.options.emulateJSON参考地址：https://github.com/pagekit/vue-resource/blob/develop/src/http/interceptor/form.js摘出源码123456789101112131415161718192021/** * Form data Interceptor. */import Url from '../../url/index';import &#123; isObject, isFormData &#125; from '../../util';export default function (request, next) &#123; if (isFormData(request.body)) &#123; request.headers.delete('Content-Type'); &#125; else if (isObject(request.body) &amp;&amp; request.emulateJSON) &#123; request.body = Url.params(request.body); request.headers.set('Content-Type', 'application/x-www-form-urlencoded'); &#125; next();&#125; 从第17行可以看到，如果设置了emulateJSON的话会默认加上这句1request.headers.set('Content-Type', 'application/x-www-form-urlencoded'); 这就是为什么我们设置的Content-Type失效了。只要去掉Vue.http.options.emulateHTTP = true 或者直接置为false就可以了。 [转自] vue-resource报错450的解决方案]]></content>
      <categories>
        <category>问题总结</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[weex-start]]></title>
    <url>%2Fweex-start%2F</url>
    <content type="text"><![CDATA[我的weex开发之路认识比较浅薄，单纯从使用方面入手，整理了两个半小时，有错误的地方还请指出。1. 构建项目创建一个项目之前，首先需要选取合适的工具，目前使用比较广的两个weex脚手架有weexpack和weex-toolkit。 weex-toolkit（创建的weex项目没有ios和android包） weex init weex 创建项目 修改weex.html文件，将./node_modules/weex-vue-render/index.js修改为./node_modules/weex-vue-render/dist/index.js cnpm install 加载依赖包 package.json中的scripts配置&quot;app&quot;: &quot;npm run build &amp; npm run dev &amp; npm run server&quot; npm run app 启动项目 目录结构如下图： weexpack （创建的weex项目有ios和android包） weexpack create weex 创建项目 weexpack platform add android 添加android weexpack platform add ios 添加ios weexpack run ios 模拟器运行 目录结构如下图： 因为我们不打包android和ios，只需要将写好的页面打包成.weex.js文件供ios和android开发人员调用，所以采用了weex init的构建方式。 2. 工具Weex DevtoolsWeex Devtools是Weex开发调试必备的神器，安装好后，终端进入到项目目录，运行weex debug 会自动打开页面 扫二维码后 点击Inspector可以看页面信息，我们打开Debugger，然后扫描打包好的js文件二维码就可以开始调试了。 注： 箭头所指处选debugger，我因为手贱选了个别的，导致好几天console里没有内容提示，还以为版本问题，后来研究了下，发现这里选错了。 3. 遇到的问题 官方demo跑不通 解决：高一点版本的weex-vue-render里index.js路径改变，导致。修改weex.html文件，将./node_modules/weex-vue-render/index.js修改为./node_modules/weex-vue-render/dist/index.js使用vue-resources获取接口数据, weex web上好的，但是weex-playground中跑不通，一片空白，错误信息：12345678910111213141516[undefined:344:31] ReferenceError: Can't find variable: documentaddStyleaddStylesToDomexports__webpack_require____webpack_require____webpack_require____webpack_require__anonymousa@main.js:4:16690main.js:7:8740 解决：weex中不支持document和window，换成其它方式。weex不支持vue-resources，改成weex支持的fetch 里loading一直没效果 解决：中使用refresh就没法用loading，去掉refresh模块webpack报错，错误信息 ERROR in Entry module not found: Error: Cannot resolve &#39;file&#39; or &#39;directory&#39; /Users/xx/xx/code/weex/app.js in /Users/xx/xx/code/weex 解决：开始一直以为是webpack入口没配置对，检查很多遍，各种测试后，发现这里真的没问题1234// entry: entriesentry: &#123; app: path.resolve('./app.js')&#125; 后来找到问题出自123resolve: &#123; extensions: ['.js', '.vue', '.json']&#125;, 原因是修改了默认的这个配置后，第一个空项不能省略，应该配置为&#123;12 extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;]&#125;, 错误信息 Cannot resolve module &#39;sass-loader&#39; 解决：缺少node-sass 或 sass-loadernpm install node-sass sass-loader --save-dev把sass-loader安装成了”scss-loader”: “0.0.1”,也是服了我自己。接口地址只能获取本地数据，配置test环境失败 解决：server.js中加一层代理123456789101112131415161718192021222324require('http-proxy-middleware')// api代理var proxyTable = config.test.proxyTableObject.keys(proxyTable).forEach(function (context) &#123; var options = proxyTable[context] if (typeof options === 'string') &#123; options = &#123; target: options &#125; &#125; server.use(proxyMiddleware(context, options))&#125;)// proxyTable数据proxyTable: &#123; '/api': &#123; // 测试服务器 target: 'http://ip地址:端口号/xx', changeOrigin: true, pathRewrite: &#123; '^/api': '' &#125; &#125;, ...&#125; weex接口调用，fetch的headers某些字段始终设置不上 解决：fetch的headers只能设置下面这些字段参考： https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS ● 人为设置了对CORS安全的首部字段集合之外的其他首部字段。该集合为： ○ Accept ○ Accept-Language ○ Content-Language ○ Content-Type (but note the additional requirements below) ○ DPR ○ Downlink ○ Save-Data ○ Viewport-Width ○ Width ● Content-Type 的值不属于下列之一: ○ application/x-www-form-urlencoded ○ multipart/form-data ○ text/plain stream的fetch使用get方式请求接口，url都会自动加上&amp;undefined，官网的例子也不例外。原本普通接口多加一个undefined也没太大影响，但是我们项目是需要根据url参数计算签名的，所以一直签名不通过。 解决：找到源码出处 weex-vue-render第2753行对get进行了特别处理，第2764行的url拼接了body和hash，因为body没有传值，所以是undefined，注释掉url+=这行就没有undefined了，但是修改node_modules中的包内容显然不是一个合理的解决方案。于是把get方式传值改为body传过来，web端好了，签名没有问题，但是真机上还是报错，排查后发现问题出在get中使用了body传值，找到开发文档，http://weex.apache.org/cn/references/modules/stream.html然后我凌乱了，为什么明明不能传body你的源码里又要有那么一行代码url += (config.url.indexOf(&#39;?&#39;) &lt;= -1 ? &#39;?&#39; : &#39;&amp;&#39;) + body + hash;。没办法，最后使用了一个超级笨的办法解决了。在签名计算的时候人为的给url加上“&amp;undefined”,计算好签名后，web中fetch参数中的url也要加上“&amp;undefined”，但是真机上是不会有&amp;undefined的，所以真机上的url需要去掉undefined，好了问题解决了。 storage中的getItem(key, callback)封装后，页面没拿到数据。 解决：storage异步造成的，使用promise解决12345678910111213const p1 = new Promise(function (resolve) &#123; storage.getItem(key, event =&gt; &#123; let ls = event.data || '' let d = secret.decrypt(ls) // 对密文字符串进行解密。 d = typeof d === 'object' ? JSON.parse(d) : d resolve(d) &#125;) &#125;) Promise.all([p1]).then(function (result) &#123; callback(result) &#125;).catch(function(err)&#123; console.log('error', err) &#125;) 页面跳转外部非js链接，在网页上是好的，但真机上一片空白1234navigator.push(&#123; url: 'https://segmentfault.com/write?freshman=1', animated: "true"&#125;) 解决：新建一个vue文件，使用weex的web标签包一层，然后打包成weex.js格式，普通调用就好了。&lt;web class=&quot;content&quot; :src=&quot;url&quot;&gt;&lt;/web&gt; 跳转weex.js页面传参 解决：直接在url后面拼接参数，新页面使用this.$getConfig().bundleUrl获取url解析一下就好了。post提交数据的是后报错415 解决：头部信息一定要和后端协议好，不允许不一致。 [转自] 我的weex开发之路]]></content>
      <categories>
        <category>探索</category>
      </categories>
      <tags>
        <tag>weex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[regexp-password]]></title>
    <url>%2Fregexp-password%2F</url>
    <content type="text"><![CDATA[正则校验密码规则1. 8-16位数字、字母和特殊字符~!@#$%^&amp;*-+=_.123var reg = /^\[~!@#$%^&amp;*\\-+=_.0-9a-zA-Z\]&#123;8,16&#125;$/; var str = '1wfwe@99$;' // 有分号 console.log(reg.test(str)) 2. 8-16位，且必须只包含数字、字母和特殊字符~!@#$%^&amp;*-+=_.123var reg = /^(?=\[~!@#$%^&amp;*\\-+=_.0-9a-zA-Z\]*\[~!@#$%^&amp;*\\-+=_.\])(?=\[~!@#$%^&amp;*\\-+=_.0-9a-zA-Z\]*\[0-9\])(?=\[~!@#$%^&amp;*\\-+=_.0-9a-zA-Z\]*\[a-zA-Z\])\[~!@#$%^&amp;*\\-+=_.0-9a-zA-Z\]&#123;8,16&#125;$/;var str = '1w@2812fhif94#$%1' // 17位console.log(reg.test(str)) 3. 感觉上面的有点长，replace了一下，但是看着也没多好，将就下吧。123456789注：x = '~!@#$%^&amp;*\\\-+=_.' // 特殊字符d = '0-9' // 数字w = 'a-zA-Z' // 字母var reg = '^(?=\[xdw\]*\[x\])(?=\[xdw\]*\[d\])(?=\[xdw\]*\[w\])\[xdw\]&#123;8,16&#125;$'.replace(/x/gi, '~!@#$%^&amp;*\\\-+=_.').replace(/d/gi, '0-9').replace(/w/gi, 'a-zA-Z');reg = new RegExp(reg);var str = '1w@28194#$%&lt;' // 有&lt;console.log(reg, reg.test(str)) 注：特殊字符里的‘-’需要转义‘\-’, 3中需要‘\-’ [转自] 正则校验密码规则]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[slice-splice-split-substring-substr]]></title>
    <url>%2Fslice-splice-split-substring-substr%2F</url>
    <content type="text"><![CDATA[slice，splice，split，substring，substr区别 12var arr = [1, 3, 5, 7, 9, 2, 4, 6, 8, 1, 2, 3, 4, 5];var str = '1, 3, 5, 7, 9, 2, 4, 6, 8, 1, 2, 3, 4, 5'; slice(): slice(i,[j])描述: 截取数组，返回截取的数组，原数组不变参数: i: 起始位置（可为负数） j: 可选，结束位置，默认结尾 12345arr.slice(1, 6) // [3, 5, 7, 9, 2]arr.slice(1) // [3, 5, 7, 9, 2, 4, 6, 8, 1, 2, 3, 4, 5]arr.slice(-1) // [5]arr.slice(-1, 1) // []arr.slice(-3, -1) // [3, 4] splice(): splice(i, n, a1, ..., ax)描述: 可删除添加数组，原数组被改变，返回删除的数组参数: i: 删除的位置（可为负数） n: 删除数量 a1, …, ax: 添加 123arr.splice(3, 4, 5, 6) // [7, 9, 2, 4]此时arr: [1, 3, 5, 5, 6, 6, 8, 1, 2, 3, 4, 5][1, 3, 5, (删除7, 9, 2, 4) （添加5, 6,） 6, 8, 1, 2, 3, 4, 5] split(): split(s, n)描述: 字符串分割为数组参数: s: 分隔符 n: 分割之后数组的长度 12str.split(',') // ["1", " 3", " 5", " 7", " 9", " 2", " 4", " 6", " 8", " 1", " 2", " 3", " 4", " 5"]str.split(',', 3) // ["1", " 3", " 5"] substring(): substring(start, stop)描述: 字符串截取参数: start: 字符串截取的起始位置 stop: 字符串结束位置 123str.substring(3, 8) // "3, 5,"等价于str.substring(8, 3) // "3, 5," substr(): substr(start, length)描述: 字符串截取参数: start: 字符串截取的起始位置 length: 截取字符串长度 1str.substr(3, 8) // "3, 5, 7," [转自] slice, splice, split, substring, substr区别]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[isarray]]></title>
    <url>%2Fisarray%2F</url>
    <content type="text"><![CDATA[鉴别数组 判断一个对象是否是数组，有五种方法，如下：12345678910111213141516171819var arr = [1, 2, 3];var obj = &#123;a:1&#125;;toString返回对象的字符串表示toString.apply(arr) === '[object Array]'; // truetoString.apply(obj) === '[object Array]'; // falseObject.prototype.toString.call(arr) === '[object Array]'; // trueObject.prototype.toString.call(obj) === '[object Array]'; // falsearr instanceof Array; // trueobj instanceof Array; // falseArray.isArray(arr); // trueArray.isArray(obj); // false// constructor 指向创建当前对象的构造函数arr.constructor === Array // trueobj.constructor === Array // false PS：基本数据类型只有五种：Null, Undifined, String, Number, Boolean引用类型：Array，Object，Function [转自] 鉴别数组]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this]]></title>
    <url>%2Fthis%2F</url>
    <content type="text"><![CDATA[判断 this 指向谁，看执行时而非定义时，只要function没有绑定在对象上调用，它的 this 就是window。箭头函数的特征是，定义在哪，this 就指向哪。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;!--允许全屏--&gt; &lt;meta content="yes" name="apple-mobile-web-app-capable" /&gt; &lt;meta content="yes" name="apple-touch-fullscreen" /&gt; &lt;meta name="data-spm" content="a215s" /&gt; &lt;meta content="telephone=no,email=no" name="format-detection" /&gt; &lt;meta content="fullscreen=yes,preventMove=no" name="ML-Config" /&gt; &lt;meta name="viewport" content="width=device-width,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"/&gt; &lt;title&gt;this&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="dom" onclick="getId()"&gt;this:&lt;/div&gt; &lt;p&gt;this关键字总是返回一个对象&lt;/p&gt; &lt;p&gt;this总是指向类的当前实例&lt;/p&gt; &lt;p&gt;this 不能赋值&lt;/p&gt; &lt;p&gt;this 不能脱离 类/对象&lt;p&gt; &lt;p&gt;this 是面向对象语言里常见的一个关键字&lt;/p&gt; &lt;p&gt;判断 this 指向谁，看执行时而非定义时，只要函数(function)没有绑定在对象上调用，它的 this 就是 window。&lt;/p&gt; &lt;p&gt;箭头函数的特征就是，定义在哪，this 就指向哪。&lt;/p&gt; &lt;script&gt; // "use strict"; // this和构造函数 function Company() &#123; this.name = 'stardew'; console.log(this, typeof this); // Company "object" &#125; var company = new Company(); console.log(company.name); // stardew // this和对象 var company = &#123; name: 'stardew', member: 300, getMember: function() &#123; console.log(this, this === company); // company true return this.member; // 300 &#125;, setMember: function(n) &#123; console.log(this); this.member = n; &#125; &#125; company.getMember(); // this和函数 function getMember() &#123; console.log(this.member); &#125; var m1 = &#123; member: 300 &#125; var m2 = &#123; member: 200 &#125; getMember.call(m1); // 300 // 全局环境的this var member = 300; function cmpy() &#123; console.log(this.member); &#125; var Company = &#123; member: 200, getMember: function() &#123; console.log(this.member) &#125; &#125; var getMember = Company.getMember; cmpy(); // 300 getMember(); // 300 // this和DOM事件 var dom = document.getElementById('dom'); dom.onclick = function() &#123; console.log('this', this); // dom &#125; function getId() &#123; console.log('id', this, this.id); // window &#125; // this可以被call/apply/bind改变 var m1 = &#123; member: 300 &#125;; var m2 = &#123; member: 200 &#125;; function showMember() &#123; console.log(this.member); &#125; showMember(); // undifined showMember.call(m1); // 300 showMember.apply(m2); // 200 showMember.bind(m2)(); // 200 // ES6箭头函数(arrow function)和this 箭头函数的特征就是，定义在哪，this就指向哪。 var company = &#123; name: 'stardew', member: 100, getMember: function() &#123; document.onclick = function () &#123; console.log(this, this.member) ; &#125; &#125; &#125; company.getMember(); // document undifined var company = &#123; name: 'stardew', member: 100, getMember: function() &#123; document.onclick = ev =&gt; &#123; console.log(this, this.member) ; // conpany 100 &#125; &#125; &#125; company.getMember(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; [转自] 详解this]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[heaps-stacks-heapstacks-queues-arrays-chain]]></title>
    <url>%2Fheaps-stacks-heapstacks-queues-arrays-chain%2F</url>
    <content type="text"><![CDATA[堆、栈、堆栈、队列、数组、链表 堆、栈、堆栈 堆、栈有两种形式，一种是数据结构中的堆、栈，还有一种是存储区的堆和栈。 1.1 数据结构 堆（heap）：一种树型数据结构，是一棵完全二叉树，堆中某个节点的值总是不大于或不小于其父节点的值。 栈（stack）：又名堆栈，是一种运算受限的线性表，仅允许在表的一端（栈顶）进行插入和删除操作。 堆栈：指的就是栈，而不是堆加栈，有人说据查是因为口误。区别： 栈是一种先进后出的数据结构。 堆可以被看成是一棵树，如：堆排序。 1.2 存储区堆和栈是两种内存分配的两个统称，都是用来从底层操作系统中获取内存的，都存储于计算机RAM。 栈：为执行线程留出的内存空间。暂时存放数据和地址，通常用来保护断点和现场。 堆：为动态分配预留的内存空间。可以任何时候分配和释放，在不知道数据大小以及数据很大的情况下使用。 在多线程环境下每一个线程都可以有他自己完全的独立的栈，但是他们共享堆。并行存取被堆控制而不是栈。 空间分配区别： 栈（操作系统）由操作系统自动分配释放 ，程序员是无法控制，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。新加数据项放在其他数据的顶部，移除时也只能移除最顶部的数据，不能越位获取。 堆（操作系统）由程序员分配释放内存，容易产生内存碎片， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。数据项位置没有固定的顺序，可以以任何顺序插入和删除。 缓存方式区别： 栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放。优势是，存取速度比堆要快，仅次于直接位于CPU中的寄存器。缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。 堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收），所以调用这些对象的速度要相对来得低一些。 程序的局部变量存在于（栈）中，全局变量存在于（静态区 ）中，动态申请数据存在于（ 堆）中。 队列：一种特殊的线性表，只允许队尾入队，队头出队操作。（可以用数组和链表实现） 数组：相同数据类型的元素按一定顺序排列的集合（栈中分配空间），便于查找。 链表：链表是一种物理存储单元上非连续、非顺序的存储结构（堆中分配空间），便于插入删除。 看到一个很好的文章：http://blog.jobbole.com/75321/ [转自] 堆、栈、堆栈、队列、数组、链表]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[url-page-process]]></title>
    <url>%2Furl-page-process%2F</url>
    <content type="text"><![CDATA[输入网址到打开页面的过程 输入网址到打开页面步骤如下： 浏览器中输入网址； 发送至DNS服务器并获得域名对应的WEB服务器的ip地址（附1. DNS域名解析）； 与WEB服务器建立TCP连接（附2. TCP三次握手，四次挥手）； 浏览器向WEB服务器的ip地址发送相应的http请求（附3. http请求）； WEB服务器响应请求并返回指定URL的数据，或错误信息，如果设定重定向，则重定向到新的URL地址； 浏览器下载数据后解析HTML源文件，解析的过程中实现对页面的排版，解析完成后在浏览器中显示基础页面（附4. 浏览器解析）； 分析页面中的超链接并显示在当前页面，重复以上过程直至无超链接需要发送，完成全部显示。 附1. DNS域名解析 （1）在浏览器中输入www.baidu.com域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。 （2）如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。 （3）如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/ip参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。 （4）如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。 （5）如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询（ISP查询），如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(baidu.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找baidu.com域服务器，重复上面的动作，进行查询，直至找到www.baidu.com主机。 （6）如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。 从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。 下图为DNS查找过程图： 域名解析过程中客户与服务器的交互过程遇一个域名对应多个ip地址时，解决方案： 1）负载平衡器 2）根据用户所处的地理位置 3）一个IP地址映射多个物理主机的路由技术：Anycast （应用广） 附2. TCP三次握手四次挥手 在理解三次握手之前先来了解一下TCP报文，头部结构如下： （1）源端口（16位 / 2字节）：源端口号 （2）目的端口（16位）：目的端口号 （3）序号（32位）：范围 [0, 232-1]，TCP连接中传送的字节流中的每一个字节都按序号编号。 （4）确认号（32位）：期望收到对方下一个报文段的第一个数据字节的序号。 （5）数据偏移（4位）：TCP报文段的数据起始距离TCP报文段的起始处有多远。TCP首部最大长度为60字节。 （6）保留（6位）：保留以后使用。 （7）紧急URG（1位）：URG=1时，会告诉系统此报文中有紧急字段，应尽快传送，优先级变高。 （8）确认ACK（1位）：ACK=1时，确认号字段有效，连接建立后所有传送的报文段都必须把ACK置1。 （9）推送PSH（1位）：当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应。在这种情况下，TCP就可以使用推送操作。这时，发送方TCP把PSH置为1，并立即创建一个报文段发送出去。揽收方TCP收到PSH=1的报文段，就尽快的推送向前，而不再等到整个缓存都填满了后再向上交付。 （10）复位RST（1位）：当RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立运输连接。还可用来拒绝一个非法报文段或拒绝打开连接。 （11）同步SYN（1位）：在建立连接时用来同步序号。 （12）终止FIN（1位）：表明发送完毕，用来释放连接。 （13）窗口（16位）：[0, 216-1]之间的整数，指发送报文段一方的接收窗口。窗口值是接收方让发送方设置其发送窗口的依据，经常是动态变化的。窗口字段明确指出了现在允许对方发送的数据量。 （14）检验和（16位）：检验首部和数据两部分，计算时要在TCP报文段之前加上12字节的伪首部。 （15）紧急指针（16位）：URG=1时才有意义，指本报文段中紧急数据的字节数，窗口为0时也可以发送紧急数据。 （16）选项（可变）：最多40字节。 备注：TCP是可靠连接，还有一种不可靠连接UDP。UDP包括首部字段和数据字段，首部字段只有8个字节，源端口、目的端口、长度和检验和，每个字段两字节。 三次握手 四次挥手 连接时需要三次握手是因为：当服务器端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。 关闭时需要四次握手是因为：当服务器端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务器端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。 TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态是因为：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假设网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。 附3. http请求 http（Hyper Text Transfer Protocol）即超文本传输协议，处于ISO网络模型的最高层（应用层），是目前网页传输的的通用协议。 http请求是指从客户端到服务器端的请求消息，包括：消息首行中对资源的请求方法、资源的标识符及使用的协议。 http协议采用了请求/响应模型，浏览器或其他客户端发出请求，服务器给与响应。 http请求包括请求头和请求体，重点主要在请求头部分，分为Request和Response。 http Request Header 请求头 字段 描述 使用 Accept 指定客户端能够接收的内容类型 Accept: application/json, text/plain, / Accept-Charset 浏览器可以接受的字符编码集 Accept-Charset: iso-8859-5 Accept-Encoding 指定浏览器可以支持的web服务器返回内容压缩编码类型 Accept-Encoding: gzip, deflate, sdch Accept-Language 浏览器可接受的语言 Accept-Language:zh-CN,zh;q=0.8 Accept-Ranges 可以请求网页实体的一个或者多个子范围字段 Accept-Ranges: bytes Authorization HTTP授权的授权证书 Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== Cache-Control 指定请求和响应遵循的缓存机制 Cache-Control: no-cache Connection 表示是否需要持久连接（HTTP 1.1默认进行持久连接） Connection: keep-alive Cookie HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。 Cookie: number=5185918; name=lujiang; Content-Length 请求的内容长度 Content-Length: 518 Content-Type 请求的与实体对应的MIME信息 Content-Type: application/x-www-form-urlencoded Date 请求发送的日期和时间 Date: Tue, 13 Dec 2016 12:09:40 GMT Expect 请求的特定的服务器行为 Expect: 100-continue From 发出请求的用户的Email From: user@mail.com Host 指定请求的服务器的域名和端口号 Host: www.baidu.com If-Match 只有请求内容与实体相匹配才有效 If-Match: “51859185185918518591851859185185918” If-Modified-Since 如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码 If-Modified-Since: Tue, 13 Dec 2016 12:09:40 GMT If-None-Match 如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变 If-None-Match: “51859185185918518591851859185185918” If-Range 如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag If-Range: “51859185185918518591851859185185918” If-Unmodified-Since 只在实体在指定时间之后未被修改才请求成功 If-Unmodified-Since: Tue, 13 Dec 2016 12:09:40 GMT Max-Forwards 限制信息通过代理和网关传送的时间 Max-Forwards: 10 Pragma 用来包含实现特定的指令 Pragma: no-cache Proxy-Authorization 连接到代理的授权证书 Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== Range 只请求实体的一部分，指定范围 Range: bytes=500-999 Referer 先前网页的地址，当前请求网页紧随其后,即来路 Referer: http://www.baidu.com/ TE 客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息 TE: trailers,deflate;q=0.5 Upgrade 向服务器指定某种传输协议以便服务器进行转换（如果支持 Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11 User-Agent User-Agent的内容包含发出请求的用户信息 User-Agent: Mozilla/5.0 (Linux; X11) Via 通知中间网关或代理服务器地址，通信协议 Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1) Warning 关于消息实体的警告信息 Warn: 188 Miscellaneous warning HTTP Responses Header 响应头 字段 描述 使用 Accept-Ranges 表明服务器是否支持指定范围请求及哪种类型的分段请求 Accept-Ranges: bytes Age 从原始服务器到代理缓存形成的估算时间（以秒计，非负 Age: 58 Allow 对某网络资源的有效的请求行为，不允许则返回405 Allow: GET, HEAD Cache-Control 告诉所有的缓存机制是否可以缓存及哪种类型 Cache-Control: no-cache Content-Encoding web服务器支持的返回内容压缩编码类型 Content-Encoding: gzip Content-Language 响应体的语言 Content-Language: en,zh Content-Length 响应体的长度 Content-Length: 518 Content-Location 请求资源可替代的备用的另一地址 Content-Location: /index.htm Content-MD5 返回资源的MD5校验值 Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ== Content-Range 在整个返回体中本部分的字节位置 Content-Range: bytes 518-5918 Content-Type 返回内容的MIME类型 Content-Type: text/html; charset=utf-8 Date 原始服务器消息发出的时间 Date: Tue, 13 Dec 2016 12:09:40 GMT ETag 请求变量的实体标签的当前值 ETag: “51859185185918518591851859185185918” Expires 响应过期的日期和时间 Expires: Tue, 13 Dec 2016 12:09:40 GMT Last-Modified 请求资源的最后修改时间 Last-Modified: Tue, 13 Dec 2016 12:09:40 GMT Location 用来重定向接收方到非请求URL的位置来完成请求或标识新的资源 Location: www.baidu.com Pragma 包括实现特定的指令，它可应用到响应链上的任何接收方 Pragma: no-cache Proxy-Authenticate 它指出认证方案和可应用到代理的该URL上的参数 Proxy-Authenticate: Basic refresh 应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持） Refresh: 5; url=www.baidu.com Retry-After 如果实体暂时不可取，通知客户端在指定时间之后再次尝试 Retry-After: 58 Server web服务器软件名称 server: Cowboy Set-Cookie 设置Http Cookie Set-Cookie: UserID=lujiang; Max-Age=3600; Version=1 Trailer 指出头域在分块传输编码的尾部存在 Trailer: Max-Forwards Transfer-Encoding 文件传输编码 Transfer-Encoding: chunked Vary 告诉下游代理是使用缓存响应还是从原始服务器请求 Vary: * Via 告知代理客户端响应是通过哪里发送的 Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1) Warning 警告实体可能存在的问题 Warning: 188 Miscellaneous warning WWW-Authenticate 表明客户端请求实体应该使用的授权方案 WWW-Authenticate: Basic 请求完成后，响应数据都会返回一个状态码（1~599），表示请求状态，各状态码映射结果如下： http状态码 http状态码100-199 用于指定客户端应相应的某些动作100继续101分组交换协200-299 用于表示请求成功200OK201被创建202被采纳203非授权信息204无内容205重置内容206部分内容300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息300多选项&nbsp;301永久地传送302找到 ( 临时重定向 )303参见其他304未改动305&nbsp;使用代理307暂时重定向400-499 用于指出客户端的错误400错误请求401未授权402要求付费403禁止404未找到405不允许的方法406不被采纳&nbsp;407要求代理授权408请求超时409冲突410过期的411要求的长度412前提不成立413请求实例太大414请求URI太大415不支持的媒体类型416无法满足的请求范围417失败的预期500-599 用于支持服务器错误500&nbsp;内部服务器错误501未被使用502网关错误503不可用的服务504网关超时505HTTP版本未被支持 附4. 浏览器解析 （1）服务器返回json数据； （2）浏览器开始自上而下载入html代码，遇到标签内的标签引用外部CSS文件； （3）浏览器发出CSS文件的请求，服务器返回CSS文件； （4）继续载入html中部分的代码，根据已获取的CSS文件，渲染页面； （5）遇到标签引用了一张图片，向服务器发出请求。浏览器不等图片下载完，继续渲染后面的代码； （6）服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码； （7）遇到包含Javascript代码的标签，运行； （8）Javascript脚本把json数据插入到dom中，浏览器重新渲染这部分代码； （9）遇到结束。 附5. 计算机网络体系结构协议划分 [转自] 输入网址到打开页面的过程]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[autojump]]></title>
    <url>%2Fautojump%2F</url>
    <content type="text"><![CDATA[mac安装autojumpautojump是一个命令行工具，它可以使用快捷命令，直接跳转到配置好的目录，而不用管现在身在何处。 安装zsh： sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; 将zsh设置成默认的shell：chsh -s /bin/zsh (重启shell) echo $SHELL可以查看用的哪个shell（bash or zsh） 安装autojump：brew install autojump（确保有brew） 使用vim .zshrc打开.zshrc（有些人会找不到.zshrc这个文件，其实安装了zsh才会有.zshrc ，在默认打开的终端目录下。可以打开终端并且ls -a查看）。 找到 plugins=，在后面添加autojump：plugins=(git autojump) 新开一行，添加：[[ -s $(brew --prefix)/etc/profile.d/autojump.sh ]] &amp;&amp; . $(brew --prefix)/etc/profile.d/autojump.sh ：wq保存退出 重启终端，autojump就可以使用了，例如： 添加一条快捷键：j -a s &#39;/Users/XXX/Desktop/code/shark’（j -a 你定义的快捷命令 ‘需要跳转的目录位置’） 进入shark：j s [转自] mac安装autojump]]></content>
      <categories>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[browser-engine]]></title>
    <url>%2Fbrowser-engine%2F</url>
    <content type="text"><![CDATA[一、浏览器内核主要指渲染引擎(Rendering Engine)，负责解析网页语法(如HTML、JavaScript)并渲染、展示网页。 。Trident内核（代表：Internet Explorer） IE、傲游、世界之窗浏览器、Avant、腾讯TT、Netscape 8、NetCaptor、Sleipnir、GOSURF、GreenBrowser和KKman等。 。Gecko内核（代表：Mozilla Firefox） Firefox、Netscape6至9。 。WebKit内核（代表：Safari、Chrome） 。Presto内核（代表：Opera7） 。Elektra内核（代表：Opera4-6） 二、JavaScript引擎用来执行JS代码，涉及到跑分。哪个浏览器更快，指JavaScript的渲染速度，而不是页面的载入速度，各个浏览器的页面载入速度差别不大（Opera逊色一些） 。Chakra 查克拉 IE9启用的新的JavaScript引擎 。SpiderMonkey / TraceMonkey / JaegerMonkey SpiderMonkey应用在Mozilla Firefox 1.0-3.0，TraceMonkey应用在Mozilla Firefox 3.5-3.6版本，JaegerMonkey应用在Mozilla Firefox 4.0及后续的版本。 。V8 Chrome、傲游3 。Nitro Safari 4及后续的版本 。Linear A/Linear B/Futhark/Carakan Linear A应用于Opera 4.0-6.1版本，Linear B应用于Opera 7.0～9.2版本，Futhark应用于Opera 9.5-10.2版本，Carakan应用于Opera 10.5及后续的版本。 。KJS KHTML对应的JavaScript引擎 [转自] 浏览器引擎]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[data-structure]]></title>
    <url>%2Fdata-structure%2F</url>
    <content type="text"><![CDATA[数据结构基础 数据结构是相互之间存在一种或多种特定关系的数据元素的集合。 数据元素相互之间的关系称为结构。 数据结构一共分四类：集合结构、线性结构、树型结构、图形结构。 集合结构：具有某种特定性质的具体的或抽象的对象汇总成的集体。除了同属于一种类型外，别无其它关系。 线性结构：元素之间存在一对一关系。 特点： 存在唯一的一个被称作“第一个”的数据元素 存在唯一的一个被称作“最后一个”的数据元素 除第第一个以外，集合中的每个数据元素均只有一个前驱 除最后一个以外，集合中每个数据元素均只有一个后继 常见类型有： 数组，链表，队列，栈。 它们之间在操作上有所区别。 例如：链表可在任意位置插入或删除元素，而队列在队尾插入元素，队头删除元素，栈只能在栈顶进行插入，删除操作。 树形结构：元素之间存在一对多关系。 常见类型有： 树 有许多特例：二叉树、平衡二叉树、查找树等。 a. 满二叉树：深度为k且有2k-1个节点的二叉树 b. 完全二叉树：深度为k，有n个节点的二叉树，当且仅当其每一个节点都与深度为k的满二叉树中编号从1至n的节点一一对应时，称之为完全二叉树。 c. huffman树：最优二叉树 i. 路径：从树中一个节点到另一个节点之间的分支构成这两个节点之间的路径 ii. 路径长度：路径上的分枝数目 iii. 树的带权路径长度为：WPL=w1l1+w2l2+...+wnln iv. 假设有n个权值{w1,w2,…,wn}，试构造一颗有n个叶子节点的二叉树，每个叶子节点带权为wi，则其中带权路径长度WPL最小的二叉树称作最优二叉树（huffman树） v. w=(5, 29, 7, 8, 14, 23, 3, 11), n=8, m=15, 构造huffman树。 教科书上结果： WPL=34 + 54 + 74 + 84 + 113 + 143 + 232 + 292 = 271 自己构造思路：从小到大排好序{3，5，7，8，11，14，23，29}，两两之和（红圈）与未构造数字（黑圈）比较，取小构造。 WPL=35 + 55 + 74 + 83 + 113 + 143 + 232 +292 = 271结论：huffman树构造结果不唯一。 图形结构：元素之间存在多对多关系，图形结构中每个结点的前驱结点数和后续结点多个数可以任意(任意多个)。 图的遍历包括深度优先遍历和广度优先遍历： 深度优先遍历：v1—&gt;v2—&gt;v4—&gt;v8—&gt;v5—&gt;v3—&gt;v6—&gt;v7 广度优先遍历：v1—&gt;v2—&gt;v3—&gt;v4—&gt;v5—&gt;v6—&gt;v7—&gt;v8 最小生成树的问题：假设要在n个城市之间建立通信联络网，则连通n个城市只需要n-1条线路。这时。自然会考虑这样一个问题，如何在节省经费的前提下建立这个通信网。 辅助表各参数说明： i行的1，2，3，4，5分别为（v2，v3，v4，v5，v6） k为最小边对应的i值 例如第三组3-3中的v6和2，表示（v1，v3，v6）与v4的最小边为v4—v6的权值2。 哈希表：根据哈希函数H(key)和处理冲突的方法将一组关键字映射到一个有限的连续的地址集（区间）上，并以关键字在地址集中的“像”作为记录在表中的存储位置，这种表便称哈希表。 构造哈希表： 直接定址法 数字分析法 平方取中法 折叠法 除留取余法 随机数法 处理冲突的方法： 开放定址法 再哈希法 链地址法 建立一个公共溢出区 常见数据结构 队列：队尾插入元素，队头删除元素。 栈：栈顶进行插入、删除操作。 堆：数组对象，可以被视为一棵完全二叉树结构。特点是父节点的值大于（小于）两个子节点的值（分别称为大顶堆和小顶堆）。 链表：物理存储单元上非连续、非顺序的存储结构。插入删除有优势，查找弱势。 数组：查找有优势，插入删除弱势，后面所有元素都需移动。 存储 栈区：由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 堆区：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。它与数据结构中的堆是两回事，分配方式倒是类似于链表。 [转自] 数据结构基础]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[extend]]></title>
    <url>%2Fextend%2F</url>
    <content type="text"><![CDATA[大多数面向对象语言都支持两种继承方式：接口继承和实现继承。 而ECMAScript中无法实现接口继承，只支持实现继承。 其实现继承主要依靠原型链来实现。 1. 原型链基本思想：利用原型让一个引用类型继承另外一个引用类型的属性和方法。1234567891011121314151617181920212223242526272829function superObj () &#123; this.name = 'lujiang';&#125;superObj.prototype.getSuperVal = function () &#123; return 'super ' + this.name;&#125;function subObj () &#123; this.name = 'weilu';&#125;subObj.prototype = new superObj();subObj.prototype.getSubVal = function () &#123; return 'sub ' + this.name;&#125;var obj = new subObj();console.log(obj.getSuperVal());// super weilu 2. 借用构造函数基本思想：在子类型构造函数的内部调用父类构造函数，通过call()和apply()方法在新创建的对象上执行构造函数。123456789101112131415161718192021function superObj () &#123; this.colors = ['yellow', 'green', 'blue'];&#125;function subObj () &#123; superObj.call(this);&#125;var obj = new subObj();obj.colors.push('purple');console.log(obj.colors);// ["yellow", "green", "blue", "purple"]var objj = new subObj();console.log(objj.colors);// ["yellow", "green", "blue"] 3. 组合继承基本思想：将原型连和借用构造函数组合起来，发挥两者之长。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function superObj (name) &#123; this.name = name; this.colors = ["yellow", "green", "blue"];&#125;superObj.prototype.getName = function () &#123; console.log('name = ' + this.name);&#125;function subObj (name, age) &#123; superObj.call(this, name); this.age = age;&#125;subObj.prototype = new superObj();subObj.prototype.constructor = subObj;subObj.prototype.getAge = function () &#123; console.log('age = ' + this.age);&#125;var obj = new subObj('lujiang', 25);obj.colors.push('purple');console.log(obj.colors);// ["yellow", "green", "blue", "purple"]obj.getName();// name = lujiangobj.getAge();// age = 25var objj = new subObj('weilu', 25.5);console.log(objj.colors);// ["yellow", "green", "blue"]objj.getName();// name = weiluobjj.getAge();// age = 25.5 4. 原型式继承基本思想：借助原型基于已有对象创建新对象。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879function object (o) &#123; function F () &#123;&#125; F.prototype = o; return new F();&#125;var Person = &#123; name: 'lujiang', colors: ['yellow', 'green', 'blue']&#125;var secondPerson = object(Person);secondPerson.name = 'weilu';secondPerson.colors.push('purple');var thirdPerson = object(Person);thirdPerson.name = 'dew';thirdPerson.colors.push('golden');console.log(Person, secondPerson, thirdPerson);// Object &#123;name: "lujiang", colors: Array[5]&#125;// F &#123;name: "weilu"&#125;// 如上，展示全：Fname: "weilu"__proto__: Objectcolors: Array[5]name: "lujiang"__proto__: Object// F &#123;name: "dew"&#125;// 如上，展示全：Fname: "dew"__proto__: Objectcolors: Array[5]name: "lujiang"__proto__: Object// ECMAScript5 Object.create = 上述 function Object// Object.create() 方法创建一个拥有指定原型和若干个指定属性的对象。var Person = &#123; name: 'lujiang', colors: ['yellow', 'green', 'blue']&#125;var secondPerson = Object.create(Person);secondPerson.name = 'weilu';secondPerson.colors.push('purple');var thirdPerson = Object.create(Person);thirdPerson.name = 'dew';thirdPerson.colors.push('golden');console.log(Person.colors, secondPerson.colors, thirdPerson.colors);// ["yellow", "green", "blue", "purple", "golden"]// ["yellow", "green", "blue", "purple", "golden"]// ["yellow", "green", "blue", "purple", "golden"]console.log(secondPerson.__proto__ === thirdPerson.__proto__);// trueconsole.log(secondPerson.__proto__ === Person);// true 5. 寄生式继承基本思想：创建一个仅用于封装继承过程的函数。12345678910111213141516171819202122232425function extend (orl) &#123; var F = Object(orl); F.getName = function () &#123; console.log('lujiang'); &#125; return F;&#125;var Person = &#123; name: 'lujiang', colors: ['yellow', 'green', 'blue']&#125;var secondPerson = extend(Person);secondPerson.getName(); // lujiang 6. 寄生组合式继承基本思想：通过借用构造函数(2)来继承属性，通过原型链(1)与与原型式继承(4)形式来继承方法。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function extend (subObj, superObj) &#123; var P = Object(superObj.prototype);// 通过原型链(1)与与原型式继承(4)形式来继承*方法* P.constructor = subObj; subObj.prototype = P;&#125;function superObj (name) &#123; this.name = name; this.colors = ['yellow', 'green', 'blue'];&#125;superObj.prototype.getName = function () &#123; console.log('name = ' + this.name);&#125;function subObj (name, age) &#123; superObj.call(this, name);// 通过借用构造函数(2)来继承*属性* this.age = age;&#125;extend(subObj, superObj);subObj.prototype.getAge = function () &#123; console.log('age = ' + this.age);&#125;var obj = new subObj('lujiang');obj.colors.push('purple');console.log(obj.colors);// ["yellow", "green", "blue", "purple"]obj.getName();// name = lujiang [转自] javascript的实现继承]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[singleton]]></title>
    <url>%2Fsingleton%2F</url>
    <content type="text"><![CDATA[单例模式（创建型）定义：一个类仅有一个实例，并提供一个访问它的全局访问点。 原理：使用一个变量来标志当前是否已经为某个类创建过实例对象，如果没有，就创建一个类实例对象，并把值赋给存储实例的变量。如果有，则在下一次获取该类的实例时，直接返回之前创建的实例对象。 举例：用一个经典的弹窗功能来举例，下面是单例模式的形成 1.点击按钮出现弹窗（多次点击，出现多个浮层）1234567891011var createMask = function () &#123; return document.body.appendChild(document.createElement('div'));&#125;$('button').click(function () &#123; var mask = createMask();&#125;); 2.添加一个全局标识，如果有直接返回，没有的话则创建（全局变量容易被污染）1234567891011121314151617var mask;var createMask = function () &#123; if (mask) &#123; return mask; &#125; else &#123; mask = document.body.appendChild(document.createElement('div')); return mask; &#125;&#125; 3.使用闭包，保护变量（适用性不广）1234567891011var createMask = function () &#123; var mask; return function () &#123; return mask || (mask = document.body.appendChild(document.createElement('div'))); &#125;&#125;(); 4.单例模式（封装一个单例）·1234567891011121314151617var singleton = function (fn) &#123; var result; return function () &#123; return result || (result = fn.apply(this, arguments)); &#125;&#125;var createMask = singleton(function () &#123; return document.body.appendChild(document.createElement('div'));&#125;); [转自] 单例模式（创建型）]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-advantages-disadvantages]]></title>
    <url>%2Fjavascript-advantages-disadvantages%2F</url>
    <content type="text"><![CDATA[参考javascript语言精粹附录及网友总结 优点：简单、灵活、跨平台 非常简单 a. 单线程 灵活 a. 灵活是指代码要实现某个功能时，可以写的很简单，也可以很复杂 b. 可以函数式编程（闭包）函数是顶级对象，函数是有词法作用域的闭包 c. 也可以面向对象编程，基于原型继承的动态对象 d. 字面量，对象字面量和数组字面量（json灵感之源） 跨平台 a. 跨系统平台以及浏览器平台,有不兼容问题 缺点：全局变量有隐患、无块级作用域、隐式类型转换错乱、闭包隐患、typeof判断不全面、+功能不明确 全局变量（最糟糕的设计）： a. 大程序里难以管理，因为全局变量可以被程序的任何部分在任意时间修改，使得程序行为变得极度复杂。降低了程序的可靠性。 b. 独立子程序变得复杂，因为如果子程序存在和全局变量名相同的变量时，会导致冲突，不容易调试。 c. 未声明的变量默认为全局变量，bug难找。 没有自带的块级作用域（ES6改善） 自动插入分号，有时会不合时宜的插入分号，掩盖严重错误。 有很多保留字很少使用，byte，enum，implements，native，package，short，volatile typeof判断不全面 typeof null typeof array parseInt，遇到非数字会停止解析 +可能是数字相加、也可能是字符串连接 浮点数0.1+0.2 != 0.3 NAN NAN != NAN 伪数组，javascript没有真正的数组 1234var arr = [1,2];if (arr &amp;&amp; typeof arr === 'object' &amp;&amp; arr.constructor === Array) &#123; console.log('true');&#125; 假值 设计比较仓促（只花了10天） 没有继承 [转自] javascript优缺点]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[track-by]]></title>
    <url>%2Ftrack-by%2F</url>
    <content type="text"><![CDATA[vue中track-by的理解api：http://cn.vuejs.org/guide/list.html#track-by 示例地址：https://jsfiddle.net/stardew/f1eju0ku/5/ 无track-by情况：数据修改时，无论值是否被修改，dom都被重新渲染（控制台可以看到） 加入track-by属性：数据修改时，不变数据所在的dom不被重新渲染，已改变的数据所在dom才被重新渲染 track-by的两种使用方法： 1. 使用数据中某唯一字段，例如_uid1234567&lt;div id="example"&gt; &lt;p v-for="item in items" track-by="_uid"&gt; &#123;&#123;item.message&#125;&#125; &lt;/p&gt; &lt;input type="button" value="修改" @click="modify"/&gt; &lt;input type="button" value="还原" @click="reduct"/&gt;&lt;/div&gt; 12345678// 初始数据items: [ &#123; _uid: '111111', message: '111' &#125;, &#123; _uid: '222222', message: '222' &#125;, &#123; _uid: '333333', message: '333' &#125;, &#123; _uid: '444444', message: '444' &#125;, &#123; _uid: '555555', message: '555' &#125;] 12345678910// 修改成modify: function () &#123; this.items = [ &#123; _uid: '111111', message: '111' &#125;, &#123; _uid: '666666', message: '222' &#125;, &#123; _uid: '333333', message: '3333' &#125;, &#123; _uid: '888888', message: '4444' &#125;, &#123; _uid: '999999', message: '5555' &#125; ]&#125; 渲染效果如下图右(左边无track-by，右边有track-by)，_uid和message都不变的情况下，才不被重新渲染，只有第一组符合条件。 2. 使用$index，其它条件同上1234567&lt;div id="example"&gt; &lt;p v-for="item in items" track-by="$index"&gt; &#123;&#123;item.message&#125;&#125; &lt;/p&gt; &lt;input type="button" value="修改" @click="modify"/&gt; &lt;input type="button" value="还原" @click="reduct"/&gt;&lt;/div&gt; 渲染效果如下图右，message的值第一、二条都没改变，所以一、二都没有重新渲染。 模板中同时使用message和_uid时，只有两者都不变的情况下才不重新渲染，如下： 1234567&lt;div id="example"&gt; &lt;p v-for="item in items" track-by="$index"&gt; &#123;&#123;item.message&#125;&#125; &#123;&#123;item._uid&#125;&#125; &lt;/p&gt; &lt;input type="button" value="修改" @click="modify"/&gt; &lt;input type="button" value="还原" @click="reduct"/&gt;&lt;/div&gt; [转自] vue中track-by的理解]]></content>
      <categories>
        <category>探索</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[regexp-important]]></title>
    <url>%2Fregexp-important%2F</url>
    <content type="text"><![CDATA[正则表达式重点总结 1. 贪婪模式 （尽可能多的去匹配符合条件的字符串）1234var str = "aaabbbbcccccAAABBBBCCCCC"; var reg = /a.*b/ig; var newStr = str.replace(reg, '笨蛋'); console.log(newStr); // 结果：笨蛋CCCCC 匹配了aaabbbbcccccAAABBBBCCCCC **非贪婪模式（尽可能少的去匹配符合条件的字符串 ‘?’ ） 1234var str = "aaabbbbcccccAAABBBBCCCCC"; var reg = /a.*?b/ig; var newStr = str.replace(reg, '笨蛋'); console.log(newStr); // 结果：笨蛋bbbccccc笨蛋BBBCCCCC 匹配了aaabbbbcccccAAABBBBCCCCC 2. 捕获组**捕获型： 12var str = "aaabbbbcccccAAABBBBCCCCC"; /[\w]&#123;3&#125;(b)*(c)*/.exec(str) // 结果：[“aaabbbbccccc”, “b”, “c”] 除了输出匹配结果，还输出了捕获到的b和c **非捕获型3种： 12var str = "aaabbbbcccccAAABBBBCCCCC"; /[\w]&#123;3&#125;(?!b)/.exec(str) // 结果：[“bbb”] 后面跟的不是b的三个字符 aaabbbbcccccAAABBBBCCCCC 12var str = "aaabbbbcccccAAABBBBCCCCC"; /[\w]&#123;3&#125;(?=b)/.exec(str) // 结果：[“aaa”] 后面跟b的三个字符 aaabbbbcccccAAABBBBCCCCC 12var str = "aaabbbbcccccAAABBBBCCCCC"; /[\w]&#123;3&#125;(?:b)/.exec(str) // 结果：[“aaab”] 三个字符后紧跟b的字符串 aaabbbbcccccAAABBBBCCCCC **更好的理解捕获(分组) 1234var reg = /((\d)(\d))/; if(reg.test('abc123ddd'))&#123; console.log(RegExp.$0, RegExp.$1, RegExp.$2, RegExp.$3) &#125; // 结果：undefined “12” “1” “2” ‘(‘ 从左到右算分组，下标从1开始 3. 方法： test、match、search、replace、split、exec、compile **test：测试str是否包含匹配，包含返回true，不包含返回false。 1234var str = "aaabbbbcccccAAABBBBCCCCC"; var reg = /ab/ig; var newStr = reg.test(str); console.log(newStr); // 结果：true **match：根据reg进行正则匹配，匹配到，返回匹配结果，否则返回null。 1234var str = "aaabbbbcccccAAABBBBCCCCC"; var reg = /ab/ig; var newStr = str.match(reg); console.log(newStr); // 结果：[“ab”, “AB”] **search ：根据reg进行正则匹配，如果匹配到一个结果，则返回它的索引数（0开始），否则返回-1。 1234ar str = "aaabbbbcccccAAABBBBCCCCC"; var reg = /bc/ig; var newStr = str. search(reg); console.log(newStr); // 结果：6 下标从0开始 **replace：根据reg进行正则匹配，把匹配结果替换为“ 笨蛋 ”。 1234var str = "aaabbbbcccccAAABBBBCCCCC"; var reg = /bc/ig; var newStr = str. replace(reg, '笨蛋'); console.log(newStr); // 结果：aaabbb笨蛋ccccAAABBB笨蛋CCCC **split：根据reg进行正则分割，返回分割后的字符串组成的数组。 1234var str = "aaabbbbcccccAAABBBBCCCCC"; var reg = /bc/ig; var newStr = str.split(reg); console.log(newStr); // 结果：[“aaabbb”, “ccccAAABBB”, “CCCC”] aaabbbbcccccAAABBBBCCCCC **exec：对str进行正则处理，并返回匹配结果。array[0]为匹配到的字符串，array[1]为匹配在整个被搜索字符串中的位置。 1234var str = "aaabbbbcccccAAABBBBCCCCC"; var reg = /bc/ig; var newStr = reg.exec(str); console.log(newStr); // 结果：[“bc”, index: 6, input: “aaabbbbcccccAAABBBBCCCCC”] **compile：用于改变和重新编译正则表达式(基本等同于构造方法方式，已被废弃) 1234567var str = "aaabbbbcccccAAABBBBCCCCC"; var reg = /bc/ig; var newStr = str.replace(reg, '笨蛋'); console.log(newStr); reg=/ab/gi; reg.compile(reg); newStr = str.replace(reg, '笨蛋'); console.log(newStr); // 结果：aaabbb笨蛋ccccAAABBB笨蛋CCCC aa笨蛋bbbcccccAA笨蛋BBBCCCCC 使用与否好像并没有区别，可以试试 [转自] 正则表达式重点总结]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wechat]]></title>
    <url>%2Fwechat%2F</url>
    <content type="text"><![CDATA[微信小程序，试试水。1. https://mp.weixin.qq.com注册一个公众号，成为开发者，拿到一个appId。 2. 下载微信开发者工具，https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html?t=1476197489869。 3. 使用微信扫码登录 4. 添加一个项目，把注册公众号获得到的appId复制到appId，名称目录填写好后，点击添加项目，显示 小程序还处于内测阶段，没有被邀请的用户获取的appId无法使用，尝试认证，但个人用户无法认证（有说关注大于500的可以，一时难以凑齐，弃之），因2013年以后公众号无法升级为服务号，于是又开始注册服务号，因为不是企业，没有各种相关信息，又弃之，最后只能选择无appId进行项目添加，虽少些功能，但也大体可以使用。 往一个空的文件夹中添加项目，会自动创建一个获取信息和登录日志的小demo，结构非常清晰（加了几个接口和一个文件夹detail图） .js =&gt; .js .wxml =&gt; .html .wxss =&gt; .css .json =&gt; .json 点击调试可以看到效果，头像，昵称，和helloword（因为是扫码登录，开发者工具绑定了开发者信息，所以可以拿到个人信息）。 点击左侧编辑可对代码进行编辑，编辑完后保存、编译就可查看新效果。 [转自] 微信小程序，试试水。]]></content>
      <categories>
        <category>探索</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git-403]]></title>
    <url>%2Fgit-403%2F</url>
    <content type="text"><![CDATA[git拉取代码报错：Permission denied (publickey) 解决方案一个菜鸟码农，之前也在git上建过一些私有项目，git clone 拉取代码也没有出过任何问题，今天手痒又新建了一个，但是一直报Permission denied (publickey)错误，不知道是不是因为同时用两个git账号拉代码导致，折腾了半上午，终于解决问题了。 基本步骤如下： 1. 设置Git的user name和email git config –global user.name “xxxx” //xxxx为git用户名 git config –global user.email “xxxx@xxxx.com” //xxxx@xxxx.com为注册git的邮箱 2. 查看是否已经有了ssh密钥：cd ~/.ssh =&gt; open ./ //成功后我的有id_rsa、id_rsa.pub、known_hosts这三个文件 如果没有密钥则不会有此文件夹，有则备份删除 3. 清除所有的公钥：ssh-add -D 删除git中的公钥：rm -r ~/.ssh 4. 重新生成公钥：ssh-keygen -t rsa -C “xxxx@xxxx.com”(三个回车) //xxxx@xxxx.com为注册git的邮箱 5. 进入ssh：cd ~/.ssh 查看公钥：vim id_rsa.pub（复制整个文件内容 &lt;=&gt; 密钥）或者：cat ~/.ssh/id_rsa.pub 复制 6. 浏览器打开git：https://git.oschina.net/keys => SSH公钥 =&gt; 粘贴复制好的公钥 =&gt; 保存 7. 最后：git clone &lt;地址&gt; 成功拉取代码 希望对你有点帮助！ [转自] git拉取代码报错：Permission denied (publickey) 解决方案]]></content>
      <categories>
        <category>问题总结</category>
      </categories>
      <tags>
        <tag>issue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-drag-and-drop]]></title>
    <url>%2Fvue-drag-and-drop%2F</url>
    <content type="text"><![CDATA[输入内容转图片（vue + html2canvas + vue-drag-and-drop）最近做了一个小工具，把输入的内容转成图片输出。使用插件 html2canvas，vue-drag-and-drop 功能：输入列表框可上下移动、拖拽、添加、删除，生成图片可预览、下载。 基本思路：把html转成canvas，然后把canvas存成图片。 完成：用插件vue-drag-and-drop，使输入列表可拖拽；刚开始自己根据输入的内容用canvas画图，但是考虑到可扩展性，最后选择html2canvas工具把html转成canvas。 遇到的问题及解决办法： 1. 开始自己根据输入所得数据用canvas一行一行画，文字断行处右边对不齐。问题成因：因为输入的文字有中文英文等，占位不同，固定每行截取字符的长度导致右端不对齐。解决：所有文字都转为英文字符数，中文占两字符，其它占一个字符，计算出行数；每行英文字符占位是固定的x，然后从开始位置往后计算x长度时，正常文字所在位置，substr截取出来，canvas画上。12345678910111213141516171819202122232425262728293031323334353637// 获取段落真实长度,包括中英文getTrueLength: function (str) &#123; let len = str.length let truelen = 0 for (let x = 0; x &lt; len; x++) &#123; if (str.charCodeAt(x) &gt; 128) &#123; truelen += 2 &#125; else &#123; truelen += 1 &#125; &#125; return truelen&#125;,// canvas画图时,文字切割cutString: function (str, leng) &#123; let len = str.length let tlen = len let nlen = 0 for (let x = 0; x &lt; len; x++) &#123; if (str.charCodeAt(x) &gt; 128) &#123; if (nlen + 2 &lt; leng) &#123; nlen += 2 &#125; else &#123; tlen = x break &#125; &#125; else &#123; if (nlen + 1 &lt; leng) &#123; nlen += 1 &#125; else &#123; tlen = x break &#125; &#125; &#125; return tlen&#125;, 2. textarea里输入的换行、空格直接存到所需样式的div里时，没效果。问题成因：编码格式不统一，textarea内容存到textarea里格式是一致的。解决：转义一下，空格替换成&nbsp;换行\r\n换为&lt;br&gt;，template里使用&#123;&#123;&#123;&#125;&#125;&#125;而非&#123;&#123;&#125;&#125;解析。12345678910nl2br: function (str, idx, tag, isXhtml) &#123; let blankTag = '&amp;nbsp;' let breakTag = (isXhtml || typeof isXhtml === 'undefined') ? '&lt;br /&gt;' : '&lt;br&gt;' let newStr = (str + '').replace(/([^&gt;\s]?)(\s)/g, '$1' + blankTag + '$2') newStr = (newStr + '').replace(/([^&gt;\r\n]?)(\r\n|\n\r|\r|\n)/g, '$1' + breakTag + '$2') if (tag) &#123; this.changeData[idx][tag] = newStr &#125; return newStr&#125;, 3. 画成的canvas，存成图片模糊。问题成因：屏幕显示和屏幕像素一样大小的图片时，尺寸相符，一个屏幕像素对应一个图像像素，显示清晰，但是一个比屏幕像素小的图片展示时，屏幕像素比图片像素多，一个图片像素要用一个多屏幕像素来显示，此时，图像显示驱动的平滑处理功能生效，显示驱动用插值算法在源图中扩展生成新的像素点，图片被拉伸，所以模糊了。解决：知道了问题的成因就好办了，可是把canvas画大一点，图片比屏幕大了就不会模糊了，简单的解决办法是使用双倍canvas高宽，画成图，toDataUrl转成.jpg图片，然后图片展示时缩放一倍。 = &gt; canvas width 1960，img width: 98012345678910111213// 文本信息保存成图片saveImageInfo: function () &#123; let mycanvas = document.getElementById('canvas') let image = mycanvas.toDataURL('image/png') let w = window.open('about:blank', 'image from canvas') w.document.write('&lt;img src="' + image + '" alt="from canvas" style="width: 980px; margin: 0 auto; display: block; height: ' + (this.canvasHeight / 2) + 'px"/&gt;')&#125;,// 存为本地图片saveAsLocalImage: function () &#123; let myCanvas = document.getElementById('canvas') let image = myCanvas.toDataURL('image/png').replace('image/png', 'image/octet-stream') window.location.href = image&#125;, 4. html2canvas把html页面存成图片时，图片不全。问题成因：html2canvas只能把当前浏览器窗口内及以下部分的内容转成图片，任何已经滚动到浏览器顶部以上以及position、fixed后的非可视的内容都无法存图解决办法：先记录当前scrollTop值，window.scrollTo(0,0)到顶部，然后画图，就可以解决了，完了再回到原来的scroll位置。1234567891011// 文本信息画成canvasdraw: function (callback) &#123; let y = document.body.scrollTop || document.documentElement.scrollTop || 0 window.scrollTo(0, 0) window.html2canvas(document.querySelector('#drawImg'), &#123;allowTaint: false, taintTest: false&#125;).then(function (canvas) &#123; this.ob.innerHTML = '' this.ob.appendChild(canvas) window.scrollTo(0, y) callback &amp;&amp; callback() &#125;.bind(this))&#125;, 5. html2canvas画出来的图片也模糊。问题成因：如3解决：因为插件里的内容别的地方可能也要用，所以不修改canvas画布大小的算法。画布的大小是所要画的html内容决定的，所以只要这个html整体放大一倍，图片再缩小一倍就可以解决了。[转自] 输入内容转图片（vue + html2canvas + vue-drag-and-drop）]]></content>
      <categories>
        <category>小例子</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx-reinstall]]></title>
    <url>%2Fnginx-reinstall%2F</url>
    <content type="text"><![CDATA[mac下重装nginxmac下彻底卸载nginx，并且重装。 nginx -s stop 停止nginx进程 which nginx 查看nginx所在目录 删除 brew remove nginx brew install nginx [转自] mac下重装nginx]]></content>
      <categories>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[regexp-basic]]></title>
    <url>%2Fregexp-basic%2F</url>
    <content type="text"><![CDATA[我对正则表达式的一点理解前几日拜读jquery源码，发现里边有大量的正则表达式，看着着实头疼，今天特地研究了一下，自己稍微沉淀了一点东西。 1. 何为正则表达式？通常情况下，我们所看到的正则表达式就是一串难懂的字符串（如：\[\\w!#$%&amp;&apos;*+/=?^_`{|}~-\]+(?:\\.\[\\w!#$%&amp;&apos;*+/=?^_`{|}~-\]+)*@(?:\[\\w\](?:\[\\w-\]*\[\\w\])?\\.)+\[\\w\](?:\[\\w-\]*\[\\w\])?），没错，正则表达式就是符合某一类规则的一串表达式。 2. 什么情况下会用到正则表达式？通常我们会在字符串的查找匹配，替换中使用到正则。 3. 如何使用正则表达式？前面也说过，正则表达式需要符合一定的规则，也就是说，按规则来书写，就基本可以满足需求，当然，只是满足基本，在实际应用中还应该考虑各种情况，这就需要添加更多的限定条件。我们先拿前面提到的正则式来举个例子。 \[\\w!#$%&amp;&apos;*+/=?^_`{|}~-\]+(?:\\.\[\\w!#$%&amp;&apos;*+/=?^_`{|}~-\]+)*@(?:\[\\w\](?:\[\\w-\]*\[\\w\])?\\.)+\[\\w\](?:\[\\w-\]*\[\\w\])? 看着这么一大串乱七八糟的字符有没有很头疼呢，我们且不说这是干什么用的，先根据附录中的规则分解剖析一番，把这个表达式分几部分 [\w!#$%&amp;’*+/=?^_`{|}~-]+ 中括号[]里面是我们要匹配的字符，后面的+是重复至少一次的意思，\w是指此字符串以下划线、数字或字母打头，或者以!#$%&amp;’+/=?^_`{|}~-中的任何一个打头，!#$%&amp;’+/=?^_`{|}~-这么一大串其实就是我们键盘顶部那些字符。 (?:\.[\w!#$%&amp;’+/=?^_`{|}~-]+) 这一串紧跟着首字符之后，小括号()里面是一个子表达式，用来分组的，(?:\.)见附录表4中的捕获，.是匹配除换行符以外的任意字符，而\.是转义之后的，单纯指.，.后必须跟字符或字符串。最后面的指重复0次或更多次的意思，小括号里面还a中出现的[\w!#$%&amp;’+/=?^_`{|}~-]+。 @ 这个就是匹配单纯的@符号，必须出现的。 (?:[\w](?:[\w-]*[\w])?\.)+ 字符或字符串以.结束，内部还嵌套了一个子表达式(?:[\w-]*[\w])?，不难理解。 [\w](?:[\w-]*[\w])? d内部嵌套的子表达式一样。 看完上面的解释，你一定也看出这个正则表达式的功能了吧，不错，正是用来匹配邮箱的。当然，上面匹配的比较严格，我们也可以简单的使用[\w+~!#$%^&amp;*()_+]+@\w+.\w+进行匹配，依项目需要了。看到这里，有没有觉得其实正则表达式并没有想象中那么可怕呢。下面我们来写一个简单的匹配电话号码的正则式（如：010-11111111,0101111111等）： ^[0]\d{2}-?\d{8}|\[0]d{3}-?\d{7,8}$ 写完之后，可以在线（http://tool.oschina.net/regex/）测试一下我们所写的正则式是否符合要求， 4. 附录：表1. 常用元字符 语法 说明 . 匹配除换行符以外的任意字符 \w 匹配字母或数字或下划线 \s 匹配任意的空白符 \d 匹配数字 \b 匹配单词的开始或结束 ^ 匹配字符串的开始 $ 匹配字符串的结束 表2.常用的限定符 语法 说明 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 表3.常用的反义代码 语法 说明 \W 匹配任意不是字母，数字，下划线的字符 \S 匹配任意不是空白符的字符 \D 匹配任意非数字的字符 \B 匹配不是单词开头或结束的位置 [^x] 匹配除了x以外的任意字符 [^aeiou] 匹配除了aeiou这几个字母以外的任意字符 表4.常用分组语法 语法 说明 捕获：(exp) 匹配exp,并捕获文本到自动命名的组里 捕获：(?exp) 匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name’exp) 捕获：(?:exp) 匹配exp,不捕获匹配的文本，也不给此分组分配组号 零宽断言：(?=exp) 匹配exp前面的位置 零宽断言：(?&lt;=exp) 匹配exp后面的位置 零宽断言：(?!exp) 匹配后面跟的不是exp的位置 零宽断言：(?&lt;!exp) 匹配前面不是exp的位置 注释：(?#comment) 这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读 表5.懒惰限定符 语法 说明 *? 重复任意次，但尽可能少重复 +? 重复1次或更多次，但尽可能少重复 ?? 重复0次或1次，但尽可能少重复 {n,m}? 重复n到m次，但尽可能少重复 {n,}? 重复n次以上，但尽可能少重复 表6.常用的处理选项 语法 说明 IgnoreCase(忽略大小写) 匹配时不区分大小写。 Multiline(多行模式) 更改^和$的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,$的精确含意是:匹配\n之前的位置以及字符串结束前的位置.)Singleline(单行模式) | 更改.的含义，使它与每一个字符匹配（包括换行符\n）。IgnorePatternWhitespace(忽略空白) | 忽略表达式中的非转义空白并启用由#标记的注释。ExplicitCapture(显式捕获) | 仅捕获已被显式命名的组。 表7.尚未详细讨论的语法 语法 说明 \a 报警字符(打印它的效果是电脑嘀一声) \b 通常是单词分界位置，但如果在字符类里使用代表退格 \t 制表符，Tab \r 回车 \v 竖向制表符 \f 换页符 \n 换行符 \e Escape \0nn ASCII代码中八进制代码为nn的字符 \xnn ASCII代码中十六进制代码为nn的字符 \unnnn Unicode代码中十六进制代码为nnnn的字符 \cN ASCII控制字符。比如\cC代表Ctrl+C \A 字符串开头(类似^，但不受处理多行选项的影响) \Z 字符串结尾或行尾(不受处理多行选项的影响) \z 字符串结尾(类似$，但不受处理多行选项的影响) \G 当前搜索的开头 \p{name} Unicode中命名为name的字符类，例如\p{IsGreek} (?&gt;exp) 贪婪子表达式 (?-exp) 平衡组 (?im-nsx:exp) 在子表达式exp中改变处理选项 (?im-nsx) 为表达式后面的部分改变处理选项 (?(exp)yes\ no) 把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no (?(exp)yes) 同上，只是使用空表达式作为no (?(name)yes\ no) 如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no (?(name)yes) 同上，只是使用空表达式作为no [转自] 我对正则表达式的一点理解]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mouse-move-trouble]]></title>
    <url>%2Fmouse-move-trouble%2F</url>
    <content type="text"><![CDATA[mouseover、mouseout防止多次触发今天做一个信息提示功能时，发现用mouseover展示提示信息，mouseout收起信息时，一直闪烁，开始以为层级关系出问题，修改许久未见成效，最后发现是因为内部元素在鼠标移上的时候会向它的父对… 下面这段文字是摘抄的： 在用到mouseover和mouseout事件来作为事件触发的条件，但是如果我们用做触发的元素内部有其他的元素的时候当鼠标移上的时候会反复的触发mouseover和mouseout事件。因为内部元素在鼠标移上的时候会向它的父对象派发事件，所以外面元素相当于也触发了mouseover 事件。 为了阻止mouseover和mouseout的反复触发，这里要用到event对象的一个属性relatedTarget，这个属性就是用来判断 mouseover和mouseout事件目标节点的相关节点的属性。简单的来说就是当触发mouseover事件时，relatedTarget属性代表的就是鼠标刚刚离开的那个节点，当触发mouseout事件时它代表的是鼠标移向的那个对象。由于MSIE不支持这个属性，不过它有代替的属性，分别是 fromElement和toElement。 有了这个属性，我们就能够清楚的知道我们的鼠标是从哪个对象移过来，又是要移动到哪里去了。这样我们就能够通过判断这个相关联的对象是否在我们要触发事件的对象的内部，或者是不是就是这个对象本身。通过这个判断我们就能够合理的选择是否真的要触发事件。 这里我们还用到了一个用于检查一个对象是否包含在另外一个对象中的方法，contains方法。MSIE和FireFox分别提供了检查的方法，这里封装了一个函数。 123456789101112131415161718/*鼠标移入移出事件 防止多次触发*/function contains(parentNode, childNode) &#123; if (parentNode.contains) &#123; return parentNode != childNode &amp;&amp; parentNode.contains(childNode); &#125; else &#123; return !!(parentNode.compareDocumentPosition(childNode) &amp; 16); &#125;&#125;function checkHover(e,target)&#123; if (getEvent(e).type=="mouseover") &#123; return !contains(target,getEvent(e).relatedTarget||getEvent(e).fromElement) &amp;&amp; !((getEvent(e).relatedTarget||getEvent(e).fromElement)===target); &#125; else &#123; return !contains(target,getEvent(e).relatedTarget||getEvent(e).toElement) &amp;&amp; !((getEvent(e).relatedTarget||getEvent(e).toElement)===target); &#125;&#125;function getEvent(e)&#123; return e||window.event;&#125;/*鼠标移入移出事件 防止多次触发*/ 1234567891011$(document).on("mouseover",".messages",function(e)&#123; if(checkHover(e,this)) &#123; $(this).addClass("on"); $(this).find(".m-txt").animate(&#123;right: "60px"&#125;, 100); &#125;&#125;).on("mouseout",".messages",function(e)&#123; if(checkHover(e,this)) &#123; $(this).removeClass("on"); $(this).find(".m-txt").animate(&#123;right: "-200px"&#125;, 100); &#125;&#125;); [转自] mouseover、mouseout防止多次触发]]></content>
      <categories>
        <category>问题总结</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[true-friend]]></title>
    <url>%2Ftrue-friend%2F</url>
    <content type="text"><![CDATA[真正的朋友真正的朋友，节日里不发短信，平时也无电话寒暄，一旦有事，拿起话筒，连一句“不好意思”的客套都不用，直奔主题。 一个普通朋友见了你点头微笑，一个真正朋友见了你没有问候； 一个普通朋友在你没有事的时候常来找你，一个真正朋友在你有事时就来找你； 一个普通朋友在喝酒时会说，你不喝完这杯就不是朋友，一个真正朋友在喝酒时会说，别喝太多了； 一个普通朋友找你借钱时总要找个借口，一个真正朋友找你借钱时总说要借多少； 一个普通朋友会带礼物来你家参加聚会，一个真正朋友从来不带东西上门，而是帮你一起做家务； 一个普通朋友从来不会看到你哭，一个真正朋友却有双肩让你湿尽； 一个普通朋友能陪你喝完一瓶烈酒，一个真正朋友能陪你长谈一个黑夜； 一个普通朋友几年不见就感到陌生，一个真正朋友十年不见却更感亲切； 一个普通朋友的电话写在电话簿上都记不住，一个真正朋友的电话没有写下来却总记得一清二楚； 一个普通朋友总爱对你说，怎么还没找到一个女朋友啊，一个真正朋友却会悄悄对你说，明天我带你去认识一个新朋友； 一个普通朋友来你家会很客气，一个真正朋友来你家自己打开冰箱拿饮料； 一个普通朋友见你做错了会装作没看见，一个真正朋友见你做错了会说，你不能这样做！ 一个普通朋友听了你唱的歌会掌声说真好听，一个真正朋友听了你唱的歌会说拜托下次别在折磨人了！ 一个普通朋友见了你叫你李科长，一个真正朋友见了你叫你老李； 一个普通朋友在春风得意时看不到你，一个真正朋友在你落魂失意时来看你； 一个普通朋友送烟给你抽，一个真正朋友却拿你烟去送人抽； 一个普通朋友常会对你说，有事尽管找我，一个真正朋友常会对你说，没事别来烦我； 一个普通朋友在你有事找他时却总说刚好没空，一个真正朋友在你有事时打电话来问你； 一个普通朋友能和你一起分享，一个真正朋友能和你分享痛苦； 一个普通朋友爱和你说他的成功往事，一个真正朋友爱和你说他的不如意和挫折失败； 一个普通朋友在和你吵架后就成了仇敌，一个真正朋友在和你吵架后依然是朋友； 一个普通朋友让你近墨者黑，一个真正朋友让你知道近墨者会黑。 [转自] 真正的朋友]]></content>
      <categories>
        <category>娱乐</category>
      </categories>
      <tags>
        <tag>joy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[who-loves-me]]></title>
    <url>%2Fwho-loves-me%2F</url>
    <content type="text"><![CDATA[谁执我之手以前一直以为是仓央嘉措写的，但是今天看又有人说是一度君华写的，不管是谁写的了，只要是好诗就值得珍藏。 谁，执我之手，敛我半世癫狂； 谁，吻我之眸，遮我半世流离； 谁，抚我之面，慰我半世哀伤； 谁，携我之心，融我半世冰霜； 伊，覆我之唇，祛我前世流离； 伊，揽我之怀，除我前世轻浮。 执子之手，陪你痴狂千生； 深吻子眸，伴你万世轮回。 我， 牵尔玉手， 收你此生所有； 我， 抚尔秀颈， 挡你此生风雨。 谁，扶我之肩，驱我一世沉寂。 谁，唤我之心，掩我一生凌轹。 谁，可明我意，使我此生无憾； 谁，可倾我心，寸土恰似虚弥； 伊，覆我之唇，祛我前世流离； 伊，揽我之怀，除我前世轻浮。 执子之手，共你一世风霜； 吻子之眸，赠你一世深情。 我， 牵尔玉手， 收你此生所有； 我， 抚尔秀颈， 挡你此生风雨。 我， 抚尔秀颈， 挡你此生风雨。 [转自] 谁执我之手]]></content>
      <categories>
        <category>娱乐</category>
      </categories>
      <tags>
        <tag>joy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mCustomScrollbar-config]]></title>
    <url>%2FmCustomScrollbar-config%2F</url>
    <content type="text"><![CDATA[mCustomScrollbar常用配置mCustomScrollbar是一个非常好用的滚动条插件，一般情况下只需作如下配置即可。 123456require(['jquery','mCustomScrollbar'],function($,mCustomScrollbar)&#123; $(".submenu-content").mCustomScrollbar(&#123; autoHideScrollbar: true, horizontalScroll:false &#125;);&#125;); 12345678910111213.mCSB_scrollTools .mCSB_draggerRail&#123;background-color: #c6c4c2;width: 8px;&#125;.mCSB_scrollTools .mCSB_dragger .mCSB_dragger_bar&#123;background-color: #c6c4c2;&#125;.mCSB_scrollTools .mCSB_dragger:hover .mCSB_dragger_bar,.mCSB_scrollTools .mCSB_dragger:active .mCSB_dragger_bar,.mCSB_scrollTools .mCSB_dragger.mCSB_dragger_onDrag .mCSB_dragger_bar &#123;background-color: #938B89;&#125;.ui-state-default&#123;background:none;&#125;.accordion-hov,.accordion-click&#123;background-color:#6e8fd0;color:#ffc600;&#125;.copyright&#123;line-height:30px;background-color:#a3a3a3;&#125;.mCSB_scrollTools.mCSB_scrollTools_horizontal .mCSB_draggerRail &#123;height: 8px;margin: 4px 0;&#125; [转自] mCustomScrollbar常用配置]]></content>
      <categories>
        <category>组件</category>
      </categories>
      <tags>
        <tag>components</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sort-algorithm]]></title>
    <url>%2Fsort-algorithm%2F</url>
    <content type="text"><![CDATA[不稳定排序（快选堆希） 简单排序中直接插入最好，快速排序最快，当文件为正序时，直接插入和冒泡均最佳。 影响因素： ①待排序的记录数目n； ②记录的大小(规模)； ③关键字的结构及其初始状态； ④对稳定性的要求； ⑤语言工具的条件； ⑥存储结构； ⑦时间和辅助空间复杂度等。 不同条件下，排序方法的选择： (1)若n较小(如n≤50)，可采用直接插入或直接选择排序。 当记录规模较小时，直接插入排序较好；否则因为直接选择移动的记录数少于直接插人，应选直接选择排序为宜。 (2)若文件初始状态基本有序(指正序)，则应选用直接插人、冒泡或随机的快速排序为宜； (3)若n较大，则应采用时间复杂度为O(nlgn)的排序方法：快速排序、堆排序或归并排序。 快速排序是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短； 堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况。这两种排序都是不稳定的。 若要求排序稳定，则可选用归并排序。但本章介绍的从单个记录起进行两两归并的 排序算法并不值得提倡，通常可以将它和直接插入排序结合在一起使用。先利用直接插入排序求得较长的有序子文件，然后再两两归并之。因为直接插入排序是稳定 的，所以改进后的归并排序仍是稳定的。 一.冒泡排序描述：两层循环，依次比较两个相邻的元素，如果反序则调换位置。 时间复杂度：时间：最好o(n), 最差o(n*(n-1)) 空间复杂度：o(1) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667function bubbleSort (arr) &#123; for (var i = 0, len = arr.length; i &lt; len; i++) &#123; for (var j = i + 1; j &lt; len; j++) &#123; if(arr[i] &gt; arr[j]) &#123; var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125; console.log(arr); &#125; return arr;&#125;var arr = [20, 1, 3, 60, 4, 6, 7, 8, 9, 8, 5, 3, 2, 30];bubbleSort(arr);/*[1, 20, 3, 60, 4, 6, 7, 8, 9, 8, 5, 3, 2, 30][1, 2, 20, 60, 4, 6, 7, 8, 9, 8, 5, 3, 3, 30][1, 2, 3, 60, 20, 6, 7, 8, 9, 8, 5, 4, 3, 30][1, 2, 3, 3, 60, 20, 7, 8, 9, 8, 6, 5, 4, 30][1, 2, 3, 3, 4, 60, 20, 8, 9, 8, 7, 6, 5, 30][1, 2, 3, 3, 4, 5, 60, 20, 9, 8, 8, 7, 6, 30][1, 2, 3, 3, 4, 5, 6, 60, 20, 9, 8, 8, 7, 30][1, 2, 3, 3, 4, 5, 6, 7, 60, 20, 9, 8, 8, 30][1, 2, 3, 3, 4, 5, 6, 7, 8, 60, 20, 9, 8, 30][1, 2, 3, 3, 4, 5, 6, 7, 8, 8, 60, 20, 9, 30][1, 2, 3, 3, 4, 5, 6, 7, 8, 8, 9, 60, 20, 30][1, 2, 3, 3, 4, 5, 6, 7, 8, 8, 9, 20, 60, 30][1, 2, 3, 3, 4, 5, 6, 7, 8, 8, 9, 20, 30, 60][1, 2, 3, 3, 4, 5, 6, 7, 8, 8, 9, 20, 30, 60][1, 2, 3, 3, 4, 5, 6, 7, 8, 8, 9, 20, 30, 60]*/ 二.快速排序描述：选取第一个为基数，大于这个基数的存入一个数组，小于这个基数的存入一个数组，最后拼接递归。 时间复杂度：时间：最好o(nlgn) , 最差o(n*n) 空间复杂度：o(lgn) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869function quickSort (arr) &#123; var len = arr.length; if (len &lt;= 1) &#123; return arr; &#125; else &#123; var base = [arr[0]]; var small = []; var big = []; for (var i=1; i&lt;len; i++) &#123; if(arr[i] &lt; base) &#123; small.push(arr[i]); &#125; else if(arr[i] &gt;= base) &#123; big.push(arr[i]); &#125; &#125; console.log(small.concat(base.concat(big))); return quickSort(small).concat(base.concat(quickSort(big))); &#125;&#125;var arr = [20, 1, 3, 60, 4, 6, 7, 8, 9, 8, 5, 3, 2, 30];quickSort(arr);/*[1, 3, 4, 6, 7, 8, 9, 8, 5, 3, 2, 20, 60, 30][1, 3, 4, 6, 7, 8, 9, 8, 5, 3, 2][2, 3, 4, 6, 7, 8, 9, 8, 5, 3][3, 4, 6, 7, 8, 9, 8, 5][5, 6, 7, 8, 9, 8][7, 8, 9, 8][8, 9, 8][8, 9][30, 60][1, 2, 3, 3, 4, 5, 6, 7, 8, 8, 9, 20, 30, 60]*/ 三.选择排序描述： 每次从数组里选出一个最小的元素，标出位置，和第一个比较，如果反序，则调换位置。 时间复杂度：时间：最好o(nn) , 最差o(nn) 空间复杂度：o(1) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081function selectSort (arr) &#123; var len = arr.length; for (var i = 0; i &lt; len; i++) &#123; var min = arr[i]; var minIdx = i; for (var j = i + 1; j &lt; len; j++) &#123; if (min &gt; arr[j]) &#123; min = arr[j]; minIdx = j &#125; &#125; if (i !== minIdx) &#123; var temp = arr[i]; arr[i] = min; arr[minIdx] = temp; &#125; console.log(arr); &#125; return arr;&#125;var arr = [20, 1, 3, 60, 4, 6, 7, 8, 9, 8, 5, 3, 2, 30];selectSort(arr);/*[1, 20, 3, 60, 4, 6, 7, 8, 9, 8, 5, 3, 2, 30][1, 2, 3, 60, 4, 6, 7, 8, 9, 8, 5, 3, 20, 30][1, 2, 3, 60, 4, 6, 7, 8, 9, 8, 5, 3, 20, 30][1, 2, 3, 3, 4, 6, 7, 8, 9, 8, 5, 60, 20, 30][1, 2, 3, 3, 4, 6, 7, 8, 9, 8, 5, 60, 20, 30][1, 2, 3, 3, 4, 5, 7, 8, 9, 8, 6, 60, 20, 30][1, 2, 3, 3, 4, 5, 6, 8, 9, 8, 7, 60, 20, 30][1, 2, 3, 3, 4, 5, 6, 7, 9, 8, 8, 60, 20, 30][1, 2, 3, 3, 4, 5, 6, 7, 8, 9, 8, 60, 20, 30][1, 2, 3, 3, 4, 5, 6, 7, 8, 8, 9, 60, 20, 30][1, 2, 3, 3, 4, 5, 6, 7, 8, 8, 9, 60, 20, 30][1, 2, 3, 3, 4, 5, 6, 7, 8, 8, 9, 20, 60, 30][1, 2, 3, 3, 4, 5, 6, 7, 8, 8, 9, 20, 30, 60][1, 2, 3, 3, 4, 5, 6, 7, 8, 8, 9, 20, 30, 60][1, 2, 3, 3, 4, 5, 6, 7, 8, 8, 9, 20, 30, 60]*/ 四.插入排序（直接插入排序）描述：按下标顺序，往一个有序数组中插入，位置为比当前数据小的元素之后 时间复杂度：时间：最好 o(n), 最差o(n*n) 空间复杂度：o(1) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071function insertSort (arr) &#123; var len = arr.length; for (var i = 0; i &lt; len - 1; i++) &#123; var idx = i + 1; var insert = arr[idx]; for (var j = i ; j &gt;= 0; j--) &#123; if (insert &lt; arr[j]) &#123; arr[j+1] = arr[j]; idx = j &#125; &#125; arr[idx] = insert; console.log(arr); &#125; return arr;&#125;var arr = [20, 1, 3, 60, 4, 6, 7, 8, 9, 8, 5, 3, 2, 30];insertSort(arr);/*[1, 20, 3, 60, 4, 6, 7, 8, 9, 8, 5, 3, 2, 30][1, 3, 20, 60, 4, 6, 7, 8, 9, 8, 5, 3, 2, 30][1, 3, 20, 60, 4, 6, 7, 8, 9, 8, 5, 3, 2, 30][1, 3, 4, 20, 60, 6, 7, 8, 9, 8, 5, 3, 2, 30][1, 3, 4, 6, 20, 60, 7, 8, 9, 8, 5, 3, 2, 30][1, 3, 4, 6, 7, 20, 60, 8, 9, 8, 5, 3, 2, 30][1, 3, 4, 6, 7, 8, 20, 60, 9, 8, 5, 3, 2, 30][1, 3, 4, 6, 7, 8, 9, 20, 60, 8, 5, 3, 2, 30][1, 3, 4, 6, 7, 8, 8, 9, 20, 60, 5, 3, 2, 30][1, 3, 4, 5, 6, 7, 8, 8, 9, 20, 60, 3, 2, 30][1, 3, 3, 4, 5, 6, 7, 8, 8, 9, 20, 60, 2, 30][1, 2, 3, 3, 4, 5, 6, 7, 8, 8, 9, 20, 60, 30][1, 2, 3, 3, 4, 5, 6, 7, 8, 8, 9, 20, 30, 60][1, 2, 3, 3, 4, 5, 6, 7, 8, 8, 9, 20, 30, 60]*/ 五.希尔排序（插入排序的一种）描述：按gap步依次比较，gap按length/2依次减小 时间复杂度：时间：最好 , 最差 空间复杂度：o(1) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859function shellSort (array) &#123; var length = array.length; var gap = Math.round(length / 2); while (gap &gt; 0) &#123; for (var i = gap; i &lt; length; i++) &#123; var insert = array[i]; var index = i; for (var j = i; j &gt;= 0; j -= gap) &#123; if (insert &lt; array[j]) &#123; array[j+gap] = array[j]; index = j; &#125; &#125; array[index] = insert; &#125; console.log(array); gap = Math.round(gap/2 - 0.1); &#125; return array;&#125;var arr = [20, 1, 3, 60, 4, 6, 7, 8, 9, 8, 5, 3, 2, 30];shellSort(arr);/*[8, 1, 3, 5, 3, 2, 7, 20, 9, 8, 60, 4, 6, 30][5, 1, 2, 6, 3, 3, 7, 20, 4, 8, 30, 9, 8, 60][1, 2, 3, 3, 4, 5, 6, 7, 8, 8, 9, 20, 30, 60][1, 2, 3, 3, 4, 5, 6, 7, 8, 8, 9, 20, 30, 60]*/ 六.归并排序描述：先将每个子序列排序，再将已有序列的子序列合并。 时间复杂度：时间：最好：n(lgn) , 最差n(lng) 空间复杂度：o(n) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185function mergeSort (array) &#123; var length = array.length; if (length &lt;= 1) &#123; return array; &#125; else &#123; var num = Math.ceil(length / 2); var left = mergeSort(array.slice(0, num)); var right = mergeSort(array.slice(num, length)); return merge(left, right); &#125;&#125;function merge (left, right) &#123; console.log(left); console.log(right); var a = new Array(); while (left.length &gt; 0 &amp;&amp; right.length &gt; 0) &#123; if (left[0] &lt;= right[0]) &#123; var temp = left.shift(); a.push(temp); &#125; else &#123; var temp = right.shift(); a.push(temp); &#125; &#125; if (left.length &gt; 0) &#123; a = a.concat(left); &#125; if (right.length &gt; 0) &#123; a = a.concat(right); &#125; console.log(a); console.log("-----------------------------"); return a;&#125;var arr = [20, 1, 3, 60, 4, 6, 7, 8, 9, 8, 5, 3, 2, 30];mergeSort(arr);/*[1][1, 20]-----------------------------[3][60][3, 60]-----------------------------[1, 20][3, 60][1, 3, 20, 60]-----------------------------[4][6][4, 6]-----------------------------[4, 6][7][4, 6, 7]-----------------------------[1, 3, 20, 60][4, 6, 7][1, 3, 4, 6, 7, 20, 60]-----------------------------[8][9][8, 9]-----------------------------[8][5][5, 8]-----------------------------[8, 9][5, 8][5, 8, 8, 9]-----------------------------[3][2][2, 3]-----------------------------[2, 3][30][2, 3, 30]-----------------------------[5, 8, 8, 9][2, 3, 30][2, 3, 5, 8, 8, 9, 30]-----------------------------[1, 3, 4, 6, 7, 20, 60][2, 3, 5, 8, 8, 9, 30][1, 2, 3, 3, 4, 5, 6, 7, 8, 8, 9, 20, 30, 60]-----------------------------[1, 2, 3, 3, 4, 5, 6, 7, 8, 8, 9, 20, 30, 60]*/ 七、堆排序（选择排序的一种）描述：先要建一棵二叉树，然后按最大堆或最小堆调节每个节点。 时间复杂度：时间：最好o(nlgn) , 最差o(nlgn) 空间复杂度：o() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115Array.prototype.buildMaxHeap = function () &#123; for (var i = Math.floor(this.length / 2) - 1; i &gt;= 0; i--) &#123; this.heapAdjust(i, this.length); &#125;&#125;;Array.prototype.swap = function (i, j) &#123; var tmp = this[i]; this[i] = this[j]; this[j] = tmp;&#125;;Array.prototype.heapSort = function () &#123; this.buildMaxHeap(); for (var i = this.length - 1; i &gt; 0; i--) &#123; this.swap(0, i); this.heapAdjust(0, i); console.log(this); &#125; return this;&#125;;Array.prototype.heapAdjust = function (i,j) &#123; var largest = i; var left = 2 * i + 1; var right = 2 * i + 2; if (left &lt; j &amp;&amp; this[largest] &lt; this[left]) &#123; largest = left; &#125; if (right &lt; j &amp;&amp; this[largest] &lt; this[right]) &#123; largest = right; &#125; if (largest != i) &#123; this.swap(i, largest); this.heapAdjust(largest, j); &#125;&#125;;var a = new Array();[].push.apply(a, [20, 1, 3, 60, 4, 6, 7, 8, 9, 8, 5, 3, 2, 30]);a.heapSort();/*[30, 20, 7, 9, 8, 6, 3, 8, 1, 4, 5, 3, 2, 60][20, 9, 7, 8, 8, 6, 3, 2, 1, 4, 5, 3, 30, 60][9, 8, 7, 3, 8, 6, 3, 2, 1, 4, 5, 20, 30, 60][8, 8, 7, 3, 5, 6, 3, 2, 1, 4, 9, 20, 30, 60][8, 5, 7, 3, 4, 6, 3, 2, 1, 8, 9, 20, 30, 60][7, 5, 6, 3, 4, 1, 3, 2, 8, 8, 9, 20, 30, 60][6, 5, 3, 3, 4, 1, 2, 7, 8, 8, 9, 20, 30, 60][5, 4, 3, 3, 2, 1, 6, 7, 8, 8, 9, 20, 30, 60][4, 3, 3, 1, 2, 5, 6, 7, 8, 8, 9, 20, 30, 60][3, 2, 3, 1, 4, 5, 6, 7, 8, 8, 9, 20, 30, 60][3, 2, 1, 3, 4, 5, 6, 7, 8, 8, 9, 20, 30, 60][2, 1, 3, 3, 4, 5, 6, 7, 8, 8, 9, 20, 30, 60][1, 2, 3, 3, 4, 5, 6, 7, 8, 8, 9, 20, 30, 60][1, 2, 3, 3, 4, 5, 6, 7, 8, 8, 9, 20, 30, 60]*/ 排序方法 最好时间 平均时间 最坏时间 辅助空间 稳定性 使用场景 冒泡 O(n) O(n2) O(n2) O(1) — 正序 快速 O(nlgn) O(nlgn) O(n2) O(lgn) 不稳定 正序、n较大 选择 O(n2) O(n2) O(n2) O(1) 不稳定 n&lt;=50(佳) 插入 O(n) O(n2) O(n2) O(1) — n&lt;=50、正序 希尔(插入) O(n) O(n1.25) O(n2) O(1) 不稳定 正序 归并 O(nlgn) O(nlgn) O(nlgn) O(n) — n较大 堆(树形选择) O(nlgn) O(nlgn) O(nlgn) O(1) 不稳定 n较大 [转自] 排序算法]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
</search>
